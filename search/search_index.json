{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"Sensor Network This repository holds the Sensor Network code stack for a LoRa based wireless sensor network. It contains the packages needed for deploying and monitoring a network with a gateway and node devices. Introduction The Sensor Network repository consists on a set of software that allows for a wireless sensor network to be deployed using the LoRa modulation technology. To this purpose, the repository includes Arduino packages for the node devices and gateway device. Additionally a python application with a GUI to monitor and manage the network is included. This application is also used to connect the network to the ROS middleware so as to provide integration with vehicles like UAVs and AGVs. The figure below depicts the network architecture used.","title":"Introduction"},{"location":"#sensor-network","text":"This repository holds the Sensor Network code stack for a LoRa based wireless sensor network. It contains the packages needed for deploying and monitoring a network with a gateway and node devices.","title":"Sensor Network"},{"location":"#introduction","text":"The Sensor Network repository consists on a set of software that allows for a wireless sensor network to be deployed using the LoRa modulation technology. To this purpose, the repository includes Arduino packages for the node devices and gateway device. Additionally a python application with a GUI to monitor and manage the network is included. This application is also used to connect the network to the ROS middleware so as to provide integration with vehicles like UAVs and AGVs. The figure below depicts the network architecture used.","title":"Introduction"},{"location":"Gateway/Classes/","text":"Classes struct strMsg Data structure that holds the encrypted payload along with other important fields. struct strPayload Data structure that holds the data for all the fields in the payload. Updated on 2022-09-09 at 17:40:14 +0000","title":"Classes"},{"location":"Gateway/Classes/#classes","text":"struct strMsg Data structure that holds the encrypted payload along with other important fields. struct strPayload Data structure that holds the data for all the fields in the payload. Updated on 2022-09-09 at 17:40:14 +0000","title":"Classes"},{"location":"Gateway/Classes/structstr_msg/","text":"strMsg Data structure that holds the encrypted payload along with other important fields. #include <comms_protocol.h> Public Attributes Name byte msg byte msgID char flag byte nodeID byte actID byte actVal Public Attributes Documentation variable msg byte msg; variable msgID byte msgID; variable flag char flag; variable nodeID byte nodeID; variable actID byte actID; variable actVal byte actVal; Updated on 2022-09-09 at 17:40:14 +0000","title":"strMsg"},{"location":"Gateway/Classes/structstr_msg/#strmsg","text":"Data structure that holds the encrypted payload along with other important fields. #include <comms_protocol.h>","title":"strMsg"},{"location":"Gateway/Classes/structstr_msg/#public-attributes","text":"Name byte msg byte msgID char flag byte nodeID byte actID byte actVal","title":"Public Attributes"},{"location":"Gateway/Classes/structstr_msg/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Gateway/Classes/structstr_msg/#variable-msg","text":"byte msg;","title":"variable msg"},{"location":"Gateway/Classes/structstr_msg/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Gateway/Classes/structstr_msg/#variable-flag","text":"char flag;","title":"variable flag"},{"location":"Gateway/Classes/structstr_msg/#variable-nodeid","text":"byte nodeID;","title":"variable nodeID"},{"location":"Gateway/Classes/structstr_msg/#variable-actid","text":"byte actID;","title":"variable actID"},{"location":"Gateway/Classes/structstr_msg/#variable-actval","text":"byte actVal; Updated on 2022-09-09 at 17:40:14 +0000","title":"variable actVal"},{"location":"Gateway/Classes/structstr_payload/","text":"strPayload Data structure that holds the data for all the fields in the payload. #include <comms_protocol.h> Public Attributes Name byte nodeID byte sensorID byte sensorVal byte msgID char flag int RSSI float SNR float VBAT double milis Public Attributes Documentation variable nodeID byte nodeID; variable sensorID byte sensorID; variable sensorVal byte sensorVal; variable msgID byte msgID; variable flag char flag; variable RSSI int RSSI; variable SNR float SNR; variable VBAT float VBAT; variable milis double milis; Updated on 2022-09-09 at 17:40:14 +0000","title":"strPayload"},{"location":"Gateway/Classes/structstr_payload/#strpayload","text":"Data structure that holds the data for all the fields in the payload. #include <comms_protocol.h>","title":"strPayload"},{"location":"Gateway/Classes/structstr_payload/#public-attributes","text":"Name byte nodeID byte sensorID byte sensorVal byte msgID char flag int RSSI float SNR float VBAT double milis","title":"Public Attributes"},{"location":"Gateway/Classes/structstr_payload/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Gateway/Classes/structstr_payload/#variable-nodeid","text":"byte nodeID;","title":"variable nodeID"},{"location":"Gateway/Classes/structstr_payload/#variable-sensorid","text":"byte sensorID;","title":"variable sensorID"},{"location":"Gateway/Classes/structstr_payload/#variable-sensorval","text":"byte sensorVal;","title":"variable sensorVal"},{"location":"Gateway/Classes/structstr_payload/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Gateway/Classes/structstr_payload/#variable-flag","text":"char flag;","title":"variable flag"},{"location":"Gateway/Classes/structstr_payload/#variable-rssi","text":"int RSSI;","title":"variable RSSI"},{"location":"Gateway/Classes/structstr_payload/#variable-snr","text":"float SNR;","title":"variable SNR"},{"location":"Gateway/Classes/structstr_payload/#variable-vbat","text":"float VBAT;","title":"variable VBAT"},{"location":"Gateway/Classes/structstr_payload/#variable-milis","text":"double milis; Updated on 2022-09-09 at 17:40:14 +0000","title":"variable milis"},{"location":"Gateway/Examples/","text":"Examples Updated on 2022-09-09 at 17:40:14 +0000","title":"Examples"},{"location":"Gateway/Examples/#examples","text":"Updated on 2022-09-09 at 17:40:14 +0000","title":"Examples"},{"location":"Gateway/Files/","text":"Files file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. file gateway_serial_definitions.h Updated on 2022-09-09 at 17:40:14 +0000","title":"Files"},{"location":"Gateway/Files/#files","text":"file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. file gateway_serial_definitions.h Updated on 2022-09-09 at 17:40:14 +0000","title":"Files"},{"location":"Gateway/Files/comms__protocol_8cpp/","text":"comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More... Functions Name cppQueue relay_q (sizeof(char) * MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE , IMPLEMENTATION ) cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message, byte nodeID) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID, byte nodeID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatusRequest (byte nodeID) Send a status request message asking for a specific node to respond with a status update. void sendActuatorControl (byte nodeID, byte actID, byte actVal) Send a control message to set a value for a node's actuator. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void relayMsgFromQueueToServer (unsigned long currentMillis) Get a message from the relay queue and send it to the server via serial communication. void constructJsonAndAddToQueue ( Payload p) Builds a json string containg the message information and adds the string to the relay queue. void relayDownlinkMsg (char * dlMsg) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. Attributes Name int currMsg int count unsigned long prevMilR unsigned long prevMil int msgCount aes256_context ctxt Detailed Description Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Functions Documentation function relay_q cppQueue relay_q( sizeof(char) * MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE , IMPLEMENTATION ) function msg_q cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION ) function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message, byte nodeID ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send nodeID ID of the destination node Return : void function encrypt byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message function decryptMsg char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b function sendAck void sendAck( byte msgID, byte nodeID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged nodeID ID of the destination node Return : void function sendStatusRequest void sendStatusRequest( byte nodeID ) Send a status request message asking for a specific node to respond with a status update. Parameters : nodeID ID of the destination node Return : void function sendActuatorControl void sendActuatorControl( byte nodeID, byte actID, byte actVal ) Send a control message to set a value for a node's actuator. Parameters : nodeID ID of the destination node actID ID of the actuator to control actVal Value to set the actuator to Return : void function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function relayMsgFromQueueToServer void relayMsgFromQueueToServer( unsigned long currentMillis ) Get a message from the relay queue and send it to the server via serial communication. Parameters : currentMillis current time in millisenconds since boot Return : void function constructJsonAndAddToQueue void constructJsonAndAddToQueue( Payload p ) Builds a json string containg the message information and adds the string to the relay queue. Parameters : p payload structure containing the message information along with RSSI, SNR and battery voltage Return : void function relayDownlinkMsg void relayDownlinkMsg( char * dlMsg ) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. Parameters : dlMsg character array containing the downlink message to be relayed function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. Parameters : packetSize size of the incoming message in bytes Attributes Documentation variable currMsg int currMsg = -1; variable count int count = 0; variable prevMilR unsigned long prevMilR; variable prevMil unsigned long prevMil; variable msgCount int msgCount = 0; variable ctxt aes256_context ctxt; Source code #include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMilR; unsigned long prevMil; int msgCount = 0; cppQueue relay_q(sizeof(char)*MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE, IMPLEMENTATION); cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.disableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); // set standby mode LoRa.enableInvertIQ(); // active invert I and Q signals } void LoRa_sendMessage(byte *message, byte nodeID) { LoRa_txMode(); LoRa.beginPacket(); LoRa.write(netID); LoRa.write(nodeID); LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); LoRa_rxMode(); } byte *encrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; const char * p = msg; static byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; } char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]) { static char data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID, byte nodeID) { String enc; char payload[MAX_PAYLOAD_SIZE]; byte l = MAX_PAYLOAD_SIZE; Msg msg; sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48); aes256_init(&ctxt, keys[(int)nodeID]); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; aes256_done(&ctxt); msg.msgID = msgID; msg.flag = 'a'; msg.nodeID = nodeID; msg_q.push(&msg); } void sendStatusRequest(byte nodeID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; msg.flag = 's'; msg.nodeID = nodeID; byte l = (byte) MAX_PAYLOAD_SIZE; sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 's', (char)48, (char)48); if (nodeID == BROADCAST_ID) aes256_init(&ctxt, keys[0]); else aes256_init(&ctxt, keys[(int)nodeID]); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; aes256_done(&ctxt); if (!msg_q.push(&msg)){ char msgText[MAX_JSON_PAYLOAD_SIZE]; sprintf(msgText, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"status\\\":\\\"%d\\\"}\", millis(), msg.msgID, 'd', msg.nodeID, 0); relay_q.push(&msgText); } } void sendActuatorControl(byte nodeID, byte actID, byte actVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; msg.actID = actID; msg.actVal = actVal; msg.flag = 'c'; msg.nodeID = nodeID; byte l = (byte)MAX_PAYLOAD_SIZE; sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'c', (char)actID, (char)actVal); aes256_init(&ctxt, keys[(int)nodeID]); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; aes256_done(&ctxt); // Add msg to msg queue msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { // START print msg queue /*Msg test; for(int i=0; i<msg_q.getCount(); i++){ msg_q.peekIdx(&test, i); Serial.print(test.msgID); Serial.print(\", \"); } Serial.println(msg_q.getCount());*/ // END print msg queue Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Payload p; p.msgID = msg.msgID; p.flag = 'd'; p.nodeID = msg.nodeID; p.sensorID = 1; // Using sensorID as status constructJsonAndAddToQueue(p); LoRa_sendMessage(msg.msg, msg.nodeID); if(msg.flag == 'a') msg_q.drop(); prevMil = currentMillis; } else { if (msg.flag == 's' || msg.flag == 'c') { Payload p; p.msgID = msg.msgID; p.flag = 'f'; p.nodeID = msg.nodeID; constructJsonAndAddToQueue(p); } msg_q.drop(); } } else { prevMil = currentMillis; } } void relayMsgFromQueueToServer(unsigned long currentMillis) { if (!relay_q.isEmpty()) { char msg[MAX_JSON_PAYLOAD_SIZE]; relay_q.pop(&msg); int i; for(i=0; i<MAX_JSON_PAYLOAD_SIZE; i++) if (msg[i] == '\\0') break; Serial.write(\"rm\"); Serial.write(msg, i); Serial.write(\"\\n\"); } prevMilR = currentMillis; } void constructJsonAndAddToQueue(Payload p) { char msg[MAX_JSON_PAYLOAD_SIZE]; switch (p.flag) { case 'u': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"sID\\\":\\\"%d\\\",\\\"sVal\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, (p.sensorID - 1), (p.sensorVal - 1), p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10); break; case 's': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"state\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, 1, p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10); break; case 'a': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"actID\\\":\\\"%d\\\",\\\"actVal\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, (p.sensorID - 1), (p.sensorVal - 1), p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10); break; case 'f': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"state\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"0\\\",\\\"SNR\\\":\\\"0\\\",\\\"VBAT\\\":\\\"0\\\"}\", millis(), p.msgID, 's', p.nodeID, 0); break; case 'd': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"status\\\":\\\"%d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, p.sensorID); break; } relay_q.push(&msg); } void relayDownlinkMsg(char *dlMsg) { char flag = dlMsg[0]; int nodeID; switch (flag) { case 's': sscanf(dlMsg, \"%*c,%d\", &nodeID); if(nodeID == -1) sendStatusRequest((byte)BROADCAST_ID); else sendStatusRequest((byte)nodeID); break; case 'c': int actID; int actVal; sscanf(dlMsg, \"%*c,%d,%d,%d\", &nodeID, &actID, &actVal); sendActuatorControl((byte)nodeID, (byte)(actID + 1), (byte)(actVal + 1)); break; case 'p': int sf; long sb; int crd; sscanf(dlMsg, \"%*c,%d,%ld,%d\", &crd, &sb, &sf); LoRa.setSignalBandwidth(sb); LoRa.setCodingRate4(crd); LoRa.setSpreadingFactor(sf); break; } } void onReceive(int packetSize) { byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available()) { buffer1[i] = (char)LoRa.read(); i++; } if (rNetID = netID) { byte len; Payload p; aes256_init(&ctxt, keys[(int)rnID]); strcpy(buffer1, decryptMsg(buffer1)); aes256_done(&ctxt); buffer1[8] = '\\0'; //Serial.println(buffer1); char a,b; //Serial.println(buffer1); if(sscanf(buffer1, \"%c%c%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal, &a, &b) == 8){ p.VBAT = (int)(a-1) + (int)(b-1) * 0.1; //Serial.println(p.VBAT); Msg msg; p.RSSI = LoRa.packetRssi(); p.SNR = LoRa.packetSnr(); if (p.flag == 'u') { sendAck(p.msgID, p.nodeID); //p.sensorVal = buffer1[14]; } if (p.flag == 's') { //sendAck(p.msgID, p.nodeID); msg_q.peek(&msg); if (p.msgID == msg.msgID) { msg_q.drop(); } } else if (p.flag == 'a') { msg_q.peek(&msg); if (p.msgID == msg.msgID) { p.sensorID = msg.actID; p.sensorVal = msg.actVal; msg_q.drop(); } } constructJsonAndAddToQueue(p); } } } Updated on 2022-09-09 at 17:40:14 +0000","title":"comms_protocol.cpp"},{"location":"Gateway/Files/comms__protocol_8cpp/#comms_protocolcpp","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More...","title":"comms_protocol.cpp"},{"location":"Gateway/Files/comms__protocol_8cpp/#functions","text":"Name cppQueue relay_q (sizeof(char) * MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE , IMPLEMENTATION ) cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message, byte nodeID) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID, byte nodeID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatusRequest (byte nodeID) Send a status request message asking for a specific node to respond with a status update. void sendActuatorControl (byte nodeID, byte actID, byte actVal) Send a control message to set a value for a node's actuator. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void relayMsgFromQueueToServer (unsigned long currentMillis) Get a message from the relay queue and send it to the server via serial communication. void constructJsonAndAddToQueue ( Payload p) Builds a json string containg the message information and adds the string to the relay queue. void relayDownlinkMsg (char * dlMsg) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server.","title":"Functions"},{"location":"Gateway/Files/comms__protocol_8cpp/#attributes","text":"Name int currMsg int count unsigned long prevMilR unsigned long prevMil int msgCount aes256_context ctxt","title":"Attributes"},{"location":"Gateway/Files/comms__protocol_8cpp/#detailed-description","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Gateway/Files/comms__protocol_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-relay_q","text":"cppQueue relay_q( sizeof(char) * MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE , IMPLEMENTATION )","title":"function relay_q"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-msg_q","text":"cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION )","title":"function msg_q"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message, byte nodeID ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send nodeID ID of the destination node Return : void","title":"function LoRa_sendMessage"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-encrypt","text":"byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message","title":"function encrypt"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-decryptmsg","text":"char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendack","text":"void sendAck( byte msgID, byte nodeID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged nodeID ID of the destination node Return : void","title":"function sendAck"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendstatusrequest","text":"void sendStatusRequest( byte nodeID ) Send a status request message asking for a specific node to respond with a status update. Parameters : nodeID ID of the destination node Return : void","title":"function sendStatusRequest"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendactuatorcontrol","text":"void sendActuatorControl( byte nodeID, byte actID, byte actVal ) Send a control message to set a value for a node's actuator. Parameters : nodeID ID of the destination node actID ID of the actuator to control actVal Value to set the actuator to Return : void","title":"function sendActuatorControl"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-relaymsgfromqueuetoserver","text":"void relayMsgFromQueueToServer( unsigned long currentMillis ) Get a message from the relay queue and send it to the server via serial communication. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function relayMsgFromQueueToServer"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-constructjsonandaddtoqueue","text":"void constructJsonAndAddToQueue( Payload p ) Builds a json string containg the message information and adds the string to the relay queue. Parameters : p payload structure containing the message information along with RSSI, SNR and battery voltage Return : void","title":"function constructJsonAndAddToQueue"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-relaydownlinkmsg","text":"void relayDownlinkMsg( char * dlMsg ) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. Parameters : dlMsg character array containing the downlink message to be relayed","title":"function relayDownlinkMsg"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. Parameters : packetSize size of the incoming message in bytes","title":"function onReceive"},{"location":"Gateway/Files/comms__protocol_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-currmsg","text":"int currMsg = -1;","title":"variable currMsg"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-count","text":"int count = 0;","title":"variable count"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-prevmilr","text":"unsigned long prevMilR;","title":"variable prevMilR"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-msgcount","text":"int msgCount = 0;","title":"variable msgCount"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Gateway/Files/comms__protocol_8cpp/#source-code","text":"#include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMilR; unsigned long prevMil; int msgCount = 0; cppQueue relay_q(sizeof(char)*MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE, IMPLEMENTATION); cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.disableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); // set standby mode LoRa.enableInvertIQ(); // active invert I and Q signals } void LoRa_sendMessage(byte *message, byte nodeID) { LoRa_txMode(); LoRa.beginPacket(); LoRa.write(netID); LoRa.write(nodeID); LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); LoRa_rxMode(); } byte *encrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; const char * p = msg; static byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; } char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]) { static char data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID, byte nodeID) { String enc; char payload[MAX_PAYLOAD_SIZE]; byte l = MAX_PAYLOAD_SIZE; Msg msg; sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48); aes256_init(&ctxt, keys[(int)nodeID]); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; aes256_done(&ctxt); msg.msgID = msgID; msg.flag = 'a'; msg.nodeID = nodeID; msg_q.push(&msg); } void sendStatusRequest(byte nodeID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; msg.flag = 's'; msg.nodeID = nodeID; byte l = (byte) MAX_PAYLOAD_SIZE; sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 's', (char)48, (char)48); if (nodeID == BROADCAST_ID) aes256_init(&ctxt, keys[0]); else aes256_init(&ctxt, keys[(int)nodeID]); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; aes256_done(&ctxt); if (!msg_q.push(&msg)){ char msgText[MAX_JSON_PAYLOAD_SIZE]; sprintf(msgText, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"status\\\":\\\"%d\\\"}\", millis(), msg.msgID, 'd', msg.nodeID, 0); relay_q.push(&msgText); } } void sendActuatorControl(byte nodeID, byte actID, byte actVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; msg.actID = actID; msg.actVal = actVal; msg.flag = 'c'; msg.nodeID = nodeID; byte l = (byte)MAX_PAYLOAD_SIZE; sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'c', (char)actID, (char)actVal); aes256_init(&ctxt, keys[(int)nodeID]); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; aes256_done(&ctxt); // Add msg to msg queue msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { // START print msg queue /*Msg test; for(int i=0; i<msg_q.getCount(); i++){ msg_q.peekIdx(&test, i); Serial.print(test.msgID); Serial.print(\", \"); } Serial.println(msg_q.getCount());*/ // END print msg queue Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Payload p; p.msgID = msg.msgID; p.flag = 'd'; p.nodeID = msg.nodeID; p.sensorID = 1; // Using sensorID as status constructJsonAndAddToQueue(p); LoRa_sendMessage(msg.msg, msg.nodeID); if(msg.flag == 'a') msg_q.drop(); prevMil = currentMillis; } else { if (msg.flag == 's' || msg.flag == 'c') { Payload p; p.msgID = msg.msgID; p.flag = 'f'; p.nodeID = msg.nodeID; constructJsonAndAddToQueue(p); } msg_q.drop(); } } else { prevMil = currentMillis; } } void relayMsgFromQueueToServer(unsigned long currentMillis) { if (!relay_q.isEmpty()) { char msg[MAX_JSON_PAYLOAD_SIZE]; relay_q.pop(&msg); int i; for(i=0; i<MAX_JSON_PAYLOAD_SIZE; i++) if (msg[i] == '\\0') break; Serial.write(\"rm\"); Serial.write(msg, i); Serial.write(\"\\n\"); } prevMilR = currentMillis; } void constructJsonAndAddToQueue(Payload p) { char msg[MAX_JSON_PAYLOAD_SIZE]; switch (p.flag) { case 'u': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"sID\\\":\\\"%d\\\",\\\"sVal\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, (p.sensorID - 1), (p.sensorVal - 1), p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10); break; case 's': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"state\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, 1, p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10); break; case 'a': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"actID\\\":\\\"%d\\\",\\\"actVal\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, (p.sensorID - 1), (p.sensorVal - 1), p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10); break; case 'f': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"state\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"0\\\",\\\"SNR\\\":\\\"0\\\",\\\"VBAT\\\":\\\"0\\\"}\", millis(), p.msgID, 's', p.nodeID, 0); break; case 'd': sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"status\\\":\\\"%d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, p.sensorID); break; } relay_q.push(&msg); } void relayDownlinkMsg(char *dlMsg) { char flag = dlMsg[0]; int nodeID; switch (flag) { case 's': sscanf(dlMsg, \"%*c,%d\", &nodeID); if(nodeID == -1) sendStatusRequest((byte)BROADCAST_ID); else sendStatusRequest((byte)nodeID); break; case 'c': int actID; int actVal; sscanf(dlMsg, \"%*c,%d,%d,%d\", &nodeID, &actID, &actVal); sendActuatorControl((byte)nodeID, (byte)(actID + 1), (byte)(actVal + 1)); break; case 'p': int sf; long sb; int crd; sscanf(dlMsg, \"%*c,%d,%ld,%d\", &crd, &sb, &sf); LoRa.setSignalBandwidth(sb); LoRa.setCodingRate4(crd); LoRa.setSpreadingFactor(sf); break; } } void onReceive(int packetSize) { byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available()) { buffer1[i] = (char)LoRa.read(); i++; } if (rNetID = netID) { byte len; Payload p; aes256_init(&ctxt, keys[(int)rnID]); strcpy(buffer1, decryptMsg(buffer1)); aes256_done(&ctxt); buffer1[8] = '\\0'; //Serial.println(buffer1); char a,b; //Serial.println(buffer1); if(sscanf(buffer1, \"%c%c%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal, &a, &b) == 8){ p.VBAT = (int)(a-1) + (int)(b-1) * 0.1; //Serial.println(p.VBAT); Msg msg; p.RSSI = LoRa.packetRssi(); p.SNR = LoRa.packetSnr(); if (p.flag == 'u') { sendAck(p.msgID, p.nodeID); //p.sensorVal = buffer1[14]; } if (p.flag == 's') { //sendAck(p.msgID, p.nodeID); msg_q.peek(&msg); if (p.msgID == msg.msgID) { msg_q.drop(); } } else if (p.flag == 'a') { msg_q.peek(&msg); if (p.msgID == msg.msgID) { p.sensorID = msg.actID; p.sensorVal = msg.actVal; msg_q.drop(); } } constructJsonAndAddToQueue(p); } } } Updated on 2022-09-09 at 17:40:14 +0000","title":"Source code"},{"location":"Gateway/Files/comms__protocol_8h/","text":"comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More... Classes Name struct strPayload Data structure that holds the data for all the fields in the payload. struct strMsg Data structure that holds the encrypted payload along with other important fields. Types Name typedef struct strPayload Payload Data structure that holds the data for all the fields in the payload. typedef struct strMsg Msg Data structure that holds the encrypted payload along with other important fields. Functions Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message, byte nodeID) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. int mymin (int a, int b) returns the minimum value between two integers char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. void onTxDone () byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. void sendAck (byte msgID, byte nodeID) Send an acknowledge message confirming the reception of an uplink transmission. void relayMsgFromQueueToServer (unsigned long currentMillis) Get a message from the relay queue and send it to the server via serial communication. void constructJsonAndAddToQueue ( Payload p) Builds a json string containg the message information and adds the string to the relay queue. void relayDownlinkMsg (char * dlMsg) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatusRequest (byte nodeID) Send a status request message asking for a specific node to respond with a status update. void sendActuatorControl (byte nodeID, byte actID, byte actVal) Send a control message to set a value for a node's actuator. Attributes Name const uint8_t keys const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMilR unsigned long prevMil int msgCount cppQueue relay_q cppQueue msg_q aes256_context ctxt Defines Name IMPLEMENTATION RELAY_INTERVAL MAX_JSON_PAYLOAD_SIZE MAX_R_QUEUE_SIZE MAX_QUEUE_SIZE MAX_N_RETRY TIMEOUT_INTERVAL BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE KEY_SIZE MAX_MSG_ID BROADCAST_ID Detailed Description Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Types Documentation typedef Payload typedef struct strPayload Payload; Data structure that holds the data for all the fields in the payload. typedef Msg typedef struct strMsg Msg; Data structure that holds the encrypted payload along with other important fields. Functions Documentation function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message, byte nodeID ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send nodeID ID of the destination node Return : void function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b function decryptMsg char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. Parameters : packetSize size of the incoming message in bytes function onTxDone void onTxDone() function encrypt byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message function sendAck void sendAck( byte msgID, byte nodeID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged nodeID ID of the destination node Return : void function relayMsgFromQueueToServer void relayMsgFromQueueToServer( unsigned long currentMillis ) Get a message from the relay queue and send it to the server via serial communication. Parameters : currentMillis current time in millisenconds since boot Return : void function constructJsonAndAddToQueue void constructJsonAndAddToQueue( Payload p ) Builds a json string containg the message information and adds the string to the relay queue. Parameters : p payload structure containing the message information along with RSSI, SNR and battery voltage Return : void function relayDownlinkMsg void relayDownlinkMsg( char * dlMsg ) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. Parameters : dlMsg character array containing the downlink message to be relayed function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function sendStatusRequest void sendStatusRequest( byte nodeID ) Send a status request message asking for a specific node to respond with a status update. Parameters : nodeID ID of the destination node Return : void function sendActuatorControl void sendActuatorControl( byte nodeID, byte actID, byte actVal ) Send a control message to set a value for a node's actuator. Parameters : nodeID ID of the destination node actID ID of the actuator to control actVal Value to set the actuator to Return : void Attributes Documentation variable keys const uint8_t keys = {{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f },{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }, { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }, { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f },{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }}; variable frequency const long frequency = 868E6; variable txPower const int txPower = 14; variable spreadingFactor const int spreadingFactor = 7; variable signalBandwidth const long signalBandwidth = 125E3; variable codingRateDenominator const int codingRateDenominator = 5; variable currMsg int currMsg; variable count int count; variable prevMilR unsigned long prevMilR; variable prevMil unsigned long prevMil; variable msgCount int msgCount; variable relay_q cppQueue relay_q; variable msg_q cppQueue msg_q; variable ctxt aes256_context ctxt; Macros Documentation define IMPLEMENTATION #define IMPLEMENTATION FIFO define RELAY_INTERVAL #define RELAY_INTERVAL 100 define MAX_JSON_PAYLOAD_SIZE #define MAX_JSON_PAYLOAD_SIZE 120 define MAX_R_QUEUE_SIZE #define MAX_R_QUEUE_SIZE 2 define MAX_QUEUE_SIZE #define MAX_QUEUE_SIZE 5 define MAX_N_RETRY #define MAX_N_RETRY 3 define TIMEOUT_INTERVAL #define TIMEOUT_INTERVAL 3000 define BLOCK_SIZE #define BLOCK_SIZE 16 define MAX_PAYLOAD_SIZE #define MAX_PAYLOAD_SIZE 16 define ENC_BLOCK_SIZE #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) define MAX_ENC_PAYLOAD_SIZE #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 define KEY_SIZE #define KEY_SIZE 32 define MAX_MSG_ID #define MAX_MSG_ID 256 define BROADCAST_ID #define BROADCAST_ID 0xFF Source code #ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include \"gateway_serial_definitions.h\" #include <cppQueue.h> #include <aes256.h> #define IMPLEMENTATION FIFO // LoRa msg payload settings #define RELAY_INTERVAL 100 #define MAX_JSON_PAYLOAD_SIZE 120 #define MAX_R_QUEUE_SIZE 2 #define MAX_QUEUE_SIZE 5 #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 3000 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define KEY_SIZE 32 #define MAX_MSG_ID 256 #define BROADCAST_ID 0xFF // Encryption keys const uint8_t keys[][KEY_SIZE] = {{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f },{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }, { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }, { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f },{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }}; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte sensorVal; byte msgID; char flag; int RSSI; float SNR; float VBAT; double milis; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; byte nodeID; byte actID; byte actVal; } Msg; extern int currMsg; extern int count; extern unsigned long prevMilR; extern unsigned long prevMil; extern int msgCount; extern cppQueue relay_q; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message, byte nodeID); int mymin(int a, int b); char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); byte *encrypt(char msg[MAX_PAYLOAD_SIZE]); void sendAck(byte msgID, byte nodeID); void relayMsgFromQueueToServer(unsigned long currentMillis); void constructJsonAndAddToQueue(Payload p); void relayDownlinkMsg(char *dlMsg); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatusRequest(byte nodeID); void sendActuatorControl(byte nodeID, byte actID, byte actVal); #endif Updated on 2022-09-09 at 17:40:14 +0000","title":"comms_protocol.h"},{"location":"Gateway/Files/comms__protocol_8h/#comms_protocolh","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More...","title":"comms_protocol.h"},{"location":"Gateway/Files/comms__protocol_8h/#classes","text":"Name struct strPayload Data structure that holds the data for all the fields in the payload. struct strMsg Data structure that holds the encrypted payload along with other important fields.","title":"Classes"},{"location":"Gateway/Files/comms__protocol_8h/#types","text":"Name typedef struct strPayload Payload Data structure that holds the data for all the fields in the payload. typedef struct strMsg Msg Data structure that holds the encrypted payload along with other important fields.","title":"Types"},{"location":"Gateway/Files/comms__protocol_8h/#functions","text":"Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message, byte nodeID) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. int mymin (int a, int b) returns the minimum value between two integers char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. void onTxDone () byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. void sendAck (byte msgID, byte nodeID) Send an acknowledge message confirming the reception of an uplink transmission. void relayMsgFromQueueToServer (unsigned long currentMillis) Get a message from the relay queue and send it to the server via serial communication. void constructJsonAndAddToQueue ( Payload p) Builds a json string containg the message information and adds the string to the relay queue. void relayDownlinkMsg (char * dlMsg) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatusRequest (byte nodeID) Send a status request message asking for a specific node to respond with a status update. void sendActuatorControl (byte nodeID, byte actID, byte actVal) Send a control message to set a value for a node's actuator.","title":"Functions"},{"location":"Gateway/Files/comms__protocol_8h/#attributes","text":"Name const uint8_t keys const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMilR unsigned long prevMil int msgCount cppQueue relay_q cppQueue msg_q aes256_context ctxt","title":"Attributes"},{"location":"Gateway/Files/comms__protocol_8h/#defines","text":"Name IMPLEMENTATION RELAY_INTERVAL MAX_JSON_PAYLOAD_SIZE MAX_R_QUEUE_SIZE MAX_QUEUE_SIZE MAX_N_RETRY TIMEOUT_INTERVAL BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE KEY_SIZE MAX_MSG_ID BROADCAST_ID","title":"Defines"},{"location":"Gateway/Files/comms__protocol_8h/#detailed-description","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Gateway/Files/comms__protocol_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#typedef-payload","text":"typedef struct strPayload Payload; Data structure that holds the data for all the fields in the payload.","title":"typedef Payload"},{"location":"Gateway/Files/comms__protocol_8h/#typedef-msg","text":"typedef struct strMsg Msg; Data structure that holds the encrypted payload along with other important fields.","title":"typedef Msg"},{"location":"Gateway/Files/comms__protocol_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message, byte nodeID ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send nodeID ID of the destination node Return : void","title":"function LoRa_sendMessage"},{"location":"Gateway/Files/comms__protocol_8h/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Gateway/Files/comms__protocol_8h/#function-decryptmsg","text":"char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg"},{"location":"Gateway/Files/comms__protocol_8h/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. Parameters : packetSize size of the incoming message in bytes","title":"function onReceive"},{"location":"Gateway/Files/comms__protocol_8h/#function-ontxdone","text":"void onTxDone()","title":"function onTxDone"},{"location":"Gateway/Files/comms__protocol_8h/#function-encrypt","text":"byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message","title":"function encrypt"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendack","text":"void sendAck( byte msgID, byte nodeID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged nodeID ID of the destination node Return : void","title":"function sendAck"},{"location":"Gateway/Files/comms__protocol_8h/#function-relaymsgfromqueuetoserver","text":"void relayMsgFromQueueToServer( unsigned long currentMillis ) Get a message from the relay queue and send it to the server via serial communication. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function relayMsgFromQueueToServer"},{"location":"Gateway/Files/comms__protocol_8h/#function-constructjsonandaddtoqueue","text":"void constructJsonAndAddToQueue( Payload p ) Builds a json string containg the message information and adds the string to the relay queue. Parameters : p payload structure containing the message information along with RSSI, SNR and battery voltage Return : void","title":"function constructJsonAndAddToQueue"},{"location":"Gateway/Files/comms__protocol_8h/#function-relaydownlinkmsg","text":"void relayDownlinkMsg( char * dlMsg ) Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. Parameters : dlMsg character array containing the downlink message to be relayed","title":"function relayDownlinkMsg"},{"location":"Gateway/Files/comms__protocol_8h/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendstatusrequest","text":"void sendStatusRequest( byte nodeID ) Send a status request message asking for a specific node to respond with a status update. Parameters : nodeID ID of the destination node Return : void","title":"function sendStatusRequest"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendactuatorcontrol","text":"void sendActuatorControl( byte nodeID, byte actID, byte actVal ) Send a control message to set a value for a node's actuator. Parameters : nodeID ID of the destination node actID ID of the actuator to control actVal Value to set the actuator to Return : void","title":"function sendActuatorControl"},{"location":"Gateway/Files/comms__protocol_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#variable-keys","text":"const uint8_t keys = {{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f },{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }, { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }, { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f },{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }};","title":"variable keys"},{"location":"Gateway/Files/comms__protocol_8h/#variable-frequency","text":"const long frequency = 868E6;","title":"variable frequency"},{"location":"Gateway/Files/comms__protocol_8h/#variable-txpower","text":"const int txPower = 14;","title":"variable txPower"},{"location":"Gateway/Files/comms__protocol_8h/#variable-spreadingfactor","text":"const int spreadingFactor = 7;","title":"variable spreadingFactor"},{"location":"Gateway/Files/comms__protocol_8h/#variable-signalbandwidth","text":"const long signalBandwidth = 125E3;","title":"variable signalBandwidth"},{"location":"Gateway/Files/comms__protocol_8h/#variable-codingratedenominator","text":"const int codingRateDenominator = 5;","title":"variable codingRateDenominator"},{"location":"Gateway/Files/comms__protocol_8h/#variable-currmsg","text":"int currMsg;","title":"variable currMsg"},{"location":"Gateway/Files/comms__protocol_8h/#variable-count","text":"int count;","title":"variable count"},{"location":"Gateway/Files/comms__protocol_8h/#variable-prevmilr","text":"unsigned long prevMilR;","title":"variable prevMilR"},{"location":"Gateway/Files/comms__protocol_8h/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Gateway/Files/comms__protocol_8h/#variable-msgcount","text":"int msgCount;","title":"variable msgCount"},{"location":"Gateway/Files/comms__protocol_8h/#variable-relay_q","text":"cppQueue relay_q;","title":"variable relay_q"},{"location":"Gateway/Files/comms__protocol_8h/#variable-msg_q","text":"cppQueue msg_q;","title":"variable msg_q"},{"location":"Gateway/Files/comms__protocol_8h/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Gateway/Files/comms__protocol_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Gateway/Files/comms__protocol_8h/#define-implementation","text":"#define IMPLEMENTATION FIFO","title":"define IMPLEMENTATION"},{"location":"Gateway/Files/comms__protocol_8h/#define-relay_interval","text":"#define RELAY_INTERVAL 100","title":"define RELAY_INTERVAL"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_json_payload_size","text":"#define MAX_JSON_PAYLOAD_SIZE 120","title":"define MAX_JSON_PAYLOAD_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_r_queue_size","text":"#define MAX_R_QUEUE_SIZE 2","title":"define MAX_R_QUEUE_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_queue_size","text":"#define MAX_QUEUE_SIZE 5","title":"define MAX_QUEUE_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_n_retry","text":"#define MAX_N_RETRY 3","title":"define MAX_N_RETRY"},{"location":"Gateway/Files/comms__protocol_8h/#define-timeout_interval","text":"#define TIMEOUT_INTERVAL 3000","title":"define TIMEOUT_INTERVAL"},{"location":"Gateway/Files/comms__protocol_8h/#define-block_size","text":"#define BLOCK_SIZE 16","title":"define BLOCK_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_payload_size","text":"#define MAX_PAYLOAD_SIZE 16","title":"define MAX_PAYLOAD_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-enc_block_size","text":"#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)","title":"define ENC_BLOCK_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_enc_payload_size","text":"#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1","title":"define MAX_ENC_PAYLOAD_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-key_size","text":"#define KEY_SIZE 32","title":"define KEY_SIZE"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_msg_id","text":"#define MAX_MSG_ID 256","title":"define MAX_MSG_ID"},{"location":"Gateway/Files/comms__protocol_8h/#define-broadcast_id","text":"#define BROADCAST_ID 0xFF","title":"define BROADCAST_ID"},{"location":"Gateway/Files/comms__protocol_8h/#source-code","text":"#ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include \"gateway_serial_definitions.h\" #include <cppQueue.h> #include <aes256.h> #define IMPLEMENTATION FIFO // LoRa msg payload settings #define RELAY_INTERVAL 100 #define MAX_JSON_PAYLOAD_SIZE 120 #define MAX_R_QUEUE_SIZE 2 #define MAX_QUEUE_SIZE 5 #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 3000 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define KEY_SIZE 32 #define MAX_MSG_ID 256 #define BROADCAST_ID 0xFF // Encryption keys const uint8_t keys[][KEY_SIZE] = {{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f },{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }, { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }, { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f },{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }}; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte sensorVal; byte msgID; char flag; int RSSI; float SNR; float VBAT; double milis; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; byte nodeID; byte actID; byte actVal; } Msg; extern int currMsg; extern int count; extern unsigned long prevMilR; extern unsigned long prevMil; extern int msgCount; extern cppQueue relay_q; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message, byte nodeID); int mymin(int a, int b); char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); byte *encrypt(char msg[MAX_PAYLOAD_SIZE]); void sendAck(byte msgID, byte nodeID); void relayMsgFromQueueToServer(unsigned long currentMillis); void constructJsonAndAddToQueue(Payload p); void relayDownlinkMsg(char *dlMsg); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatusRequest(byte nodeID); void sendActuatorControl(byte nodeID, byte actID, byte actVal); #endif Updated on 2022-09-09 at 17:40:14 +0000","title":"Source code"},{"location":"Gateway/Files/gateway__serial_8ino/","text":"gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. More... Functions Name void setup () Arduino setup function. void loop () Arduino loop function. Detailed Description Gateway script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022 Functions Documentation function setup void setup() Arduino setup function. Function: setup Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode void function loop void loop() Arduino loop function. Function: loop Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. void Source code #include \"comms_protocol.h\" void setup() { Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.write(\"LoRa init failed.\\n\"); while (true); // if failed, do nothing } LoRa.setTxPower(txPower); LoRa.setSignalBandwidth(signalBandwidth); LoRa.setCodingRate4(codingRateDenominator); LoRa.setSpreadingFactor(spreadingFactor); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); Serial.write(\"Startup complete\\n\"); } void loop() { unsigned long currentMillis = millis(); int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Receive downlink msgs from server if (Serial.available() > 0) { String dlMsg = Serial.readString(); char msg[dlMsg.length()]; dlMsg.toCharArray(msg, dlMsg.length()); relayDownlinkMsg(msg); } //if((currentMillis-prevMilR) > RELAY_INTERVAL){ relayMsgFromQueueToServer(currentMillis); //} if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ //sendStatusRequest(1); getMsgFromQueueAndSend(currentMillis); } } Updated on 2022-09-09 at 17:40:14 +0000","title":"gateway_serial.ino"},{"location":"Gateway/Files/gateway__serial_8ino/#gateway_serialino","text":"Gateway script - send sensor data to gateway and receive commands from gateway. More...","title":"gateway_serial.ino"},{"location":"Gateway/Files/gateway__serial_8ino/#functions","text":"Name void setup () Arduino setup function. void loop () Arduino loop function.","title":"Functions"},{"location":"Gateway/Files/gateway__serial_8ino/#detailed-description","text":"Gateway script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Gateway/Files/gateway__serial_8ino/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Gateway/Files/gateway__serial_8ino/#function-setup","text":"void setup() Arduino setup function.","title":"function setup"},{"location":"Gateway/Files/gateway__serial_8ino/#function-setup_1","text":"Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode void","title":"Function: setup"},{"location":"Gateway/Files/gateway__serial_8ino/#function-loop","text":"void loop() Arduino loop function.","title":"function loop"},{"location":"Gateway/Files/gateway__serial_8ino/#function-loop_1","text":"Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. void","title":"Function: loop"},{"location":"Gateway/Files/gateway__serial_8ino/#source-code","text":"#include \"comms_protocol.h\" void setup() { Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.write(\"LoRa init failed.\\n\"); while (true); // if failed, do nothing } LoRa.setTxPower(txPower); LoRa.setSignalBandwidth(signalBandwidth); LoRa.setCodingRate4(codingRateDenominator); LoRa.setSpreadingFactor(spreadingFactor); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); Serial.write(\"Startup complete\\n\"); } void loop() { unsigned long currentMillis = millis(); int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Receive downlink msgs from server if (Serial.available() > 0) { String dlMsg = Serial.readString(); char msg[dlMsg.length()]; dlMsg.toCharArray(msg, dlMsg.length()); relayDownlinkMsg(msg); } //if((currentMillis-prevMilR) > RELAY_INTERVAL){ relayMsgFromQueueToServer(currentMillis); //} if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ //sendStatusRequest(1); getMsgFromQueueAndSend(currentMillis); } } Updated on 2022-09-09 at 17:40:14 +0000","title":"Source code"},{"location":"Gateway/Files/gateway__serial__definitions_8h/","text":"gateway_serial_definitions.h Attributes Name const int gatewayID const byte netID Defines Name BAUD_RATE SS RST DIO0 Attributes Documentation variable gatewayID const int gatewayID = 0xFF; variable netID const byte netID = 0xF3; Macros Documentation define BAUD_RATE #define BAUD_RATE 9600 define SS #define SS 10 define RST #define RST 9 define DIO0 #define DIO0 2 Source code /* * Header file for the gateway program. Contains hardware pinouts, * LoRa modem configs and gateway settings */ #ifndef GATEWAY_SERIAL_DEFINITIONS_H #define GATEWAY_SERIAL_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 9600 // SPI pinout for TTGO boards //#define SCK 5 //#define MISO 19 //#define MOSI 27 // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Gateway Settings const int gatewayID = 0xFF; const byte netID = 0xF3; #endif Updated on 2022-09-09 at 17:40:14 +0000","title":"gateway_serial_definitions.h"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#gateway_serial_definitionsh","text":"","title":"gateway_serial_definitions.h"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#attributes","text":"Name const int gatewayID const byte netID","title":"Attributes"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#defines","text":"Name BAUD_RATE SS RST DIO0","title":"Defines"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#variable-gatewayid","text":"const int gatewayID = 0xFF;","title":"variable gatewayID"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#variable-netid","text":"const byte netID = 0xF3;","title":"variable netID"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-baud_rate","text":"#define BAUD_RATE 9600","title":"define BAUD_RATE"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-ss","text":"#define SS 10","title":"define SS"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-rst","text":"#define RST 9","title":"define RST"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-dio0","text":"#define DIO0 2","title":"define DIO0"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#source-code","text":"/* * Header file for the gateway program. Contains hardware pinouts, * LoRa modem configs and gateway settings */ #ifndef GATEWAY_SERIAL_DEFINITIONS_H #define GATEWAY_SERIAL_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 9600 // SPI pinout for TTGO boards //#define SCK 5 //#define MISO 19 //#define MOSI 27 // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Gateway Settings const int gatewayID = 0xFF; const byte netID = 0xF3; #endif Updated on 2022-09-09 at 17:40:14 +0000","title":"Source code"},{"location":"Gateway/Modules/","text":"Modules Updated on 2022-09-09 at 17:40:14 +0000","title":"Modules"},{"location":"Gateway/Modules/#modules","text":"Updated on 2022-09-09 at 17:40:14 +0000","title":"Modules"},{"location":"Gateway/Namespaces/","text":"Namespaces Updated on 2022-09-09 at 17:40:14 +0000","title":"Namespaces"},{"location":"Gateway/Namespaces/#namespaces","text":"Updated on 2022-09-09 at 17:40:14 +0000","title":"Namespaces"},{"location":"Gateway/Pages/","text":"Pages Updated on 2022-09-09 at 17:40:14 +0000","title":"Pages"},{"location":"Gateway/Pages/#pages","text":"Updated on 2022-09-09 at 17:40:14 +0000","title":"Pages"},{"location":"Network_Manager/Classes/","text":"Classes namespace network_manager Updated on 2022-09-09 at 17:40:17 +0000","title":"Classes"},{"location":"Network_Manager/Classes/#classes","text":"namespace network_manager Updated on 2022-09-09 at 17:40:17 +0000","title":"Classes"},{"location":"Network_Manager/Examples/","text":"Examples Updated on 2022-09-09 at 17:40:17 +0000","title":"Examples"},{"location":"Network_Manager/Examples/#examples","text":"Updated on 2022-09-09 at 17:40:17 +0000","title":"Examples"},{"location":"Network_Manager/Files/","text":"Files dir /sensor_network/network_manager/src file /sensor_network/network_manager/src/NewCallback.m file /sensor_network/network_manager/src/network_manager.py file /sensor_network/network_manager/src/stats_plotter.m Updated on 2022-09-09 at 17:40:17 +0000","title":"Files"},{"location":"Network_Manager/Files/#files","text":"dir /sensor_network/network_manager/src file /sensor_network/network_manager/src/NewCallback.m file /sensor_network/network_manager/src/network_manager.py file /sensor_network/network_manager/src/stats_plotter.m Updated on 2022-09-09 at 17:40:17 +0000","title":"Files"},{"location":"Network_Manager/Files/_new_callback_8m/","text":"/sensor_network/network_manager/src/NewCallback.m Attributes Name function output_txt Attributes Documentation variable output_txt function output_txt = myfunction(obj,event_obj) % Display the position of the data cursor % obj Currently not used (empty) % event_obj Handle to event object % output_txt Data cursor text string (string or cell array of strings). pos = get(event_obj,'Position'); Source code function output_txt = myfunction(obj,event_obj) % Display the position of the data cursor % obj Currently not used (empty) % event_obj Handle to event object % output_txt Data cursor text string (string or cell array of strings). pos = get(event_obj,'Position'); output_txt = {['Y: ',num2str(pos(2),4)]}; % If there is a Z-coordinate in the position, display it as well if length(pos) > 2 output_txt{end+1} = ['Z: ',num2str(pos(3),4)]; end Updated on 2022-09-09 at 17:40:17 +0000","title":"/sensor_network/network_manager/src/NewCallback.m"},{"location":"Network_Manager/Files/_new_callback_8m/#sensor_networknetwork_managersrcnewcallbackm","text":"","title":"/sensor_network/network_manager/src/NewCallback.m"},{"location":"Network_Manager/Files/_new_callback_8m/#attributes","text":"Name function output_txt","title":"Attributes"},{"location":"Network_Manager/Files/_new_callback_8m/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Network_Manager/Files/_new_callback_8m/#variable-output_txt","text":"function output_txt = myfunction(obj,event_obj) % Display the position of the data cursor % obj Currently not used (empty) % event_obj Handle to event object % output_txt Data cursor text string (string or cell array of strings). pos = get(event_obj,'Position');","title":"variable output_txt"},{"location":"Network_Manager/Files/_new_callback_8m/#source-code","text":"function output_txt = myfunction(obj,event_obj) % Display the position of the data cursor % obj Currently not used (empty) % event_obj Handle to event object % output_txt Data cursor text string (string or cell array of strings). pos = get(event_obj,'Position'); output_txt = {['Y: ',num2str(pos(2),4)]}; % If there is a Z-coordinate in the position, display it as well if length(pos) > 2 output_txt{end+1} = ['Z: ',num2str(pos(3),4)]; end Updated on 2022-09-09 at 17:40:17 +0000","title":"Source code"},{"location":"Network_Manager/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"/sensor_network/network_manager/src Files Name /sensor_network/network_manager/src/network_manager.py /sensor_network/network_manager/src/NewCallback.m /sensor_network/network_manager/src/stats_plotter.m Updated on 2022-09-09 at 17:40:17 +0000","title":"/sensor_network/network_manager/src"},{"location":"Network_Manager/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#sensor_networknetwork_managersrc","text":"","title":"/sensor_network/network_manager/src"},{"location":"Network_Manager/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name /sensor_network/network_manager/src/network_manager.py /sensor_network/network_manager/src/NewCallback.m /sensor_network/network_manager/src/stats_plotter.m Updated on 2022-09-09 at 17:40:17 +0000","title":"Files"},{"location":"Network_Manager/Files/network__manager_8py/","text":"/sensor_network/network_manager/src/network_manager.py Namespaces Name network_manager Source code #!/usr/bin/env python3 import serial from parse import parse import threading import PySimpleGUI as sg import json from datetime import datetime import numpy as np import matplotlib.pyplot as plt from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg plt.rcParams.update({'font.size': 6}) import yaml import csv import time # Global variables declaration. maxNum = 5 gateway_status = \"Offline\" _VARS = {'rssi_canvas': None, 'snr_canvas': None, 'dl_msgs': { 'timestamps': list(), 'nodeID': list(), 'msgID': list(), 'delay': list(), }} def network_test(): runs = 50 msg_delay = 10 print('Starting test!') for i in range(runs): global stop_threads for node in nodes: if stop_threads: return data = 's,' + str(node['id']) send_dl_msg(data) #print(datetime.now(), data) time.sleep(msg_delay) print('Test finished!') def draw_figure(canvas, figure): figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) figure_canvas_agg.draw_idle() figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) return figure_canvas_agg def send_dl_msg(data): data = bytes(data, encoding='utf-8') ser.write(data) ser.write(bytes(\"\\n\", encoding='utf-8')) ser.flush() def export_data(path): #print(path) with open(path, 'w', newline='') as csvfile: writer = csv.writer(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL) for node in nodes: for i in range(len(node['timestamps'])): writer.writerow([node['timestamps'][i], node['delay_list'][i], node['msgID_list'][i], node['id'], node['rssi_list'][i], node['snr_list'][i], node['battery_list'][i], '0']) for i in range(len(_VARS['dl_msgs']['timestamps'])): writer.writerow([_VARS['dl_msgs']['timestamps'][i], _VARS['dl_msgs']['delay'][i], _VARS['dl_msgs']['msgID'][i], _VARS['dl_msgs']['nodeID'][i], 0, 0, 0, '1']) print('Data exported!') #timestamp, nodeID, rssi, snr, battery, DL/UL #if DL we only care about timestamp and nodeID # set up custom commands for DLMSG: test1, test2 -> execute predetermined tests and save data def gui(): sg.theme('BrownBlue') global active_nodes global nodes global total_nodes node_keys = {'Node ' + str(node['id']): node for node in nodes} sensor_pane_layout = [ sg.Column([ [sg.Text('Sensor ID:', background_color='white', text_color='black'), sg.Text('id', background_color='white', text_color='black', key='_SID'+str(i)+'_')], [sg.Text('Sensor Name:', background_color='white', text_color='black'), sg.Text('name', background_color='white', text_color='black', key='_SNAME'+str(i)+'_')], [sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('never', background_color='white', text_color='black', key='_SLA'+str(i)+'_')], [sg.Text('State:', background_color='white', text_color='black'), sg.Text('unknown', background_color='white', text_color='black', key='_SSTATE'+str(i)+'_')], ], expand_y = True, background_color='white', key='_SCOL'+str(i)+'_', visible=False) for i in range(maxNum)] actuator_pane_layout = [ sg.Column([ [sg.Text('Actuator ID:', background_color='white', text_color='black'), sg.Text('id', background_color='white', text_color='black', key='_AID'+str(i)+'_')], [sg.Text('Actuator Name:', background_color='white', text_color='black'), sg.Text('name', background_color='white', text_color='black', key='_ANAME'+str(i)+'_')], [sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('never', background_color='white', text_color='black', key='_ALA'+str(i)+'_')], [sg.Text('State:', background_color='white', text_color='black'), sg.Text('unknown', background_color='white', text_color='black', key='_ASTATE'+str(i)+'_')], [sg.Button('ON', key='_AON'+str(i)+'_'),sg.Button('OFF', key='_AOFF'+str(i)+'_')], ], expand_y = True, background_color='white', key='_ACOL'+str(i)+'_', visible=False) for i in range(maxNum)] status_tab_layout = [ [ sg.Text('Node State:', background_color='white', text_color='black'), sg.Text('Offline', key='_NSTATE_', background_color='white', text_color='red') ], [ sg.Text('Node Location:', background_color='white', text_color='black'), sg.Text('', key='_NLOCATION_', background_color='white', text_color='black') ], [ sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('None', key='_NLASTACTIVITY_', background_color='white', text_color='black') ], [ sg.Text('Sensors:', background_color='white', text_color='black'), ], [ sg.Column( layout=[sensor_pane_layout], key='_SENSORSPANE_', scrollable = True, size = (None, 110), expand_x=True) ], [ sg.Text('Actuators:', background_color='white', text_color='black'), ], [ sg.Column( layout=[actuator_pane_layout], key='_ACTUATORSPANE_', scrollable = True, size = (None, 145), expand_x=True) ] ] info_tab_layout = [ [ sg.Text('Packets sent:', background_color='white', text_color='black'), sg.Text('0', key='_PACKETSSENT_', background_color='white', text_color='black') ], #[ # sg.Text('Packets received:', background_color='white', text_color='black'), # sg.Text('0', key='_PACKETSRECEIVED_', background_color='white', text_color='black') #], [ sg.Text('Average RSSI:', background_color='white', text_color='black'), sg.Text('', key='_AVGRSSI_', background_color='white', text_color='black') ], [ sg.Text('Average SNR:', background_color='white', text_color='black'), sg.Text('', key='_AVGSNR_', background_color='white', text_color='black') ], [ sg.Text('Battery Level (V):', background_color='white', text_color='black'), sg.Text('', key='_BAT_', background_color='white', text_color='black') ], [ sg.Column(layout = [ [ sg.Frame(layout = [[sg.Canvas(key='rssi_canvas', background_color=sg.theme_background_color())]], title = \"RSSI vs Packet\", size=(250,250)), sg.Frame(layout = [[sg.Canvas(key='snr_canvas', background_color=sg.theme_background_color())]], title = \"SNR vs Packet\", size=(250,250)) ] ], scrollable=False, expand_x = True, expand_y = True) ] ] layout = [ [ sg.Text('Active Nodes:'), sg.Text(str(active_nodes), key='_ACTIVENODES_'), sg.Text('/'), sg.Text( str(total_nodes), key='_TOTALNODES_') ], [ sg.Text('Gateway Status:'), sg.Text(gateway_status, key='_GATEWAYSTATUS_', text_color='red'), sg.Push(), sg.Text('Boot time:'), sg.Text('', key='_BOOTTIME_') ], [sg.Text('Send Downlink Message'), sg.InputText(key='_DLMSG_'), sg.Button('Send')], [sg.HorizontalSeparator()], [ sg.Listbox(values=list(node_keys.keys()), size=(15, 27), key='_LIST_', enable_events=True, select_mode='LISTBOX_SELECT_MODE_SINGLE', default_values=['Node 1']), sg.VerticalSeparator(), sg.TabGroup([ [sg.Tab(title='Node 1 Status', key='_STATUSTAB_', background_color='white', layout = status_tab_layout)], [sg.Tab(title='Node 1 Stats', key='_STATSTAB_', background_color='white', layout = info_tab_layout)] ], tab_location='topleft', size=(600,None), selected_background_color='white', tab_background_color=sg.theme_background_color(), selected_title_color=sg.theme_background_color(), title_color='white' ) ], [sg.Output(size=(119,8))], [ sg.Button('Rescan Network', key='_RSNET_'), sg.Button('Start Test', key='_TEST_'), sg.InputText(visible=False, enable_events=True, key='export_data_path'), sg.FileSaveAs('Export data', key='_EXPORT_', file_types=(('CSV', '.csv'),)), sg.Push(), sg.Button('Exit') ] ] global window window = sg.Window('Sensor Network Manager', layout, finalize=True) for i in range(len(nodes)): plt.figure(num=0) plt.plot([],[],'.k') #nodes[i]['rssi_plot_canvas'] = FigureCanvasTkAgg(plt.figure(num=0), window.Element('rssi_canvas').TKCanvas) _VARS['rssi_canvas'] = FigureCanvasTkAgg(plt.figure(num=0), window.Element('rssi_canvas').TKCanvas) #nodes[i]['rssi_plot_canvas'].get_tk_widget().hide() nodes[i]['rssi_list'] = list() plt.figure(num=1) plt.plot([],[],'.k') #nodes[i]['snr_plot_canvas'] = FigureCanvasTkAgg(plt.figure(num=1), window.Element('snr_canvas').TKCanvas) _VARS['snr_canvas'] = FigureCanvasTkAgg(plt.figure(num=1), window.Element('snr_canvas').TKCanvas) nodes[i]['snr_list'] = list() nodes[i]['timestamps'] = list() nodes[i]['battery_list'] = list() nodes[i]['msgID_list'] = list() nodes[i]['delay_list'] = list() while True: event, values = window.read(timeout = 200) if event == sg.WIN_CLOSED or event == 'Exit': break if event == '_TEST_': global nt_thread nt_thread.start() if event == 'export_data_path': path = values['export_data_path'] export_data(path) if event == 'Send' and len(values['_DLMSG_']): data = values['_DLMSG_'] send_dl_msg(data) window.Element('_DLMSG_').update(value=\"\") if event == '_LIST_' and len(values['_LIST_']): r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) idx = int(r[0])-1 window.Element('_STATUSTAB_').update(title='Node ' + str(idx+1) + ' Status') window.Element('_STATSTAB_').update(title='Node ' + str(idx+1) + ' Stats') updateTabs(idx) if event == '_RSNET_': active_nodes = 0 window.Element('_ACTIVENODES_').update(value=str(active_nodes)) for i in range(len(nodes)): nodes[i][\"state\"] = 0 r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) idx = int(r[0])-1 #updateTabs(idx) send_dl_msg(\"s,-1\\n\") if '_AON' in event: r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) nID = int(r[0]) r = parse(\"_AON{}_\", str(event)) actID = int(r[0]) actID = nodes[nID-1]['actuators'][actID]['id'] data = 'c,' + str(nID) + ',' + str(actID) + ',1' send_dl_msg(data) if '_AOFF' in event: r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) nID = int(r[0]) r = parse(\"_AOFF{}_\", str(event)) actID = int(r[0]) actID = nodes[nID-1]['actuators'][actID]['id'] data = 'c,' + str(nID) + ',' + str(actID) + ',0' send_dl_msg(data) window.refresh() window.close() firstTime = True def updateTabs(idx): global nodes global window window.Element('_NSTATE_').update(value='Online' if int(nodes[idx]['state']) else 'Offline', text_color='green' if int(nodes[idx]['state']) else 'red') window.Element('_NLASTACTIVITY_').update(value=str(nodes[idx]['last_activity'])) window.Element('_NLOCATION_').update(value=str(nodes[idx]['location'])) window.Element('_PACKETSSENT_').update(value=str(nodes[idx]['packets_sent'])) #window.Element('_PACKETSRECEIVED_').update(value=str(nodes[idx]['packets_received'])) window.Element('_PACKETSSENT_').update(value=str(nodes[idx]['packets_sent'])) window.Element('_AVGRSSI_').update(value=str(nodes[idx]['avg_rssi'])) window.Element('_AVGSNR_').update(value=str(nodes[idx]['avg_snr'])) window.Element('_BAT_').update(value=str(nodes[idx]['battery'])) # \\\\ -------- PYPLOT -------- // if(len(nodes[idx]['rssi_list'])>0): #nodes[idx]['rssi_plot_canvas'].get_tk_widget().forget() _VARS['rssi_canvas'].get_tk_widget().forget() plt.figure(num=0) plt.clf() plt.plot(range(1,len(nodes[idx]['rssi_list'])+1), nodes[idx]['rssi_list'], 'bo-', linewidth=0.5, markersize=3) plt.xticks(np.arange(1, len(nodes[idx]['rssi_list'])+1)) plt.ylim(-120, 20) #nodes[idx]['rssi_plot_canvas'] = draw_figure(window.Element('rssi_canvas').TKCanvas, plt.figure(num=0)) _VARS['rssi_canvas'] = draw_figure(window.Element('rssi_canvas').TKCanvas, plt.figure(num=0)) #nodes[idx]['snr_plot_canvas'].get_tk_widget().forget() _VARS['snr_canvas'].get_tk_widget().forget() plt.figure(num=1) plt.clf() plt.plot(range(1,len(nodes[idx]['snr_list'])+1), nodes[idx]['snr_list'], 'bo-', linewidth=0.5, markersize=3) plt.xticks(np.arange(1, len(nodes[idx]['snr_list'])+1)) plt.ylim(-15, 15) #nodes[idx]['snr_plot_canvas'] = draw_figure(window.Element('snr_canvas').TKCanvas, plt.figure(num=1)) _VARS['snr_canvas'] = draw_figure(window.Element('snr_canvas').TKCanvas, plt.figure(num=1)) # \\\\ -------- PYPLOT -------- // for i in range(maxNum): if i < len(nodes[idx]['sensors']): window.Element('_SCOL'+str(i)+'_').update(visible=True) window.Element('_SID'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['id'])) window.Element('_SNAME'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['name'])) window.Element('_SLA'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['last_activity'])) window.Element('_SSTATE'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['state'])) else: window.Element('_SCOL'+str(i)+'_').update(visible=False) for i in range(maxNum): if i < len(nodes[idx]['actuators']): window.Element('_ACOL'+str(i)+'_').update(visible=True) window.Element('_AID'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['id'])) window.Element('_ANAME'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['name'])) window.Element('_ALA'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['last_activity'])) window.Element('_ASTATE'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['state'])) else: window.Element('_ACOL'+str(i)+'_').update(visible=False) window.Element('_SENSORSPANE_').contents_changed() window.Element('_ACTUATORSPANE_').contents_changed() def serial_comm(): while True: global stop_threads if stop_threads: break global nodes global window line = ser.readline() line = line.decode('utf-8', \"ignore\") if(len(line) > 4): line = line.strip('rm').strip('\\n').rstrip() if line == \"Startup complete\": window.Element('_GATEWAYSTATUS_').update(value=line, text_color='#42cf68') window.Element('_BOOTTIME_').update(value=datetime.now().strftime(\"%d/%m/%Y %H:%M:%S\")) else: try: print(datetime.now(), line) msg = json.loads(line) if(msg['f'] == 'd'): _VARS['dl_msgs']['nodeID'].append(msg['nID']) _VARS['dl_msgs']['timestamps'].append(datetime.now()) _VARS['dl_msgs']['msgID'].append(msg['msgID']) _VARS['dl_msgs']['delay'].append(msg['t']) else: nidx = int(msg['nID'])-1 now = datetime.now() dt_string = now.strftime(\"%d/%m/%Y %H:%M:%S\") if(int(msg['RSSI']) != 0): nodes[int(msg['nID'])-1]['packets_sent'] += 1 t_packets = nodes[int(msg['nID'])-1]['packets_sent'] + nodes[int(msg['nID'])-1]['packets_received'] avg_rssi = float(nodes[int(msg['nID'])-1]['avg_rssi']) * float(t_packets-1)/t_packets + float(msg['RSSI']) * float(1/t_packets) avg_snr = nodes[int(msg['nID'])-1]['avg_snr'] * float(t_packets-1)/t_packets + float(msg['SNR']) * float(1/t_packets) bat = float(msg['VBAT']) nodes[int(msg['nID'])-1]['avg_rssi'] = round(avg_rssi, 2) nodes[int(msg['nID'])-1]['avg_snr'] = round(avg_snr, 2) nodes[int(msg['nID'])-1]['battery'] = round(bat, 1) for node in nodes: if int(node['id']) == int(msg['nID']): node['rssi_list'] += [float(msg['RSSI'])] node['snr_list'] += [float(msg['SNR'])] node['battery_list'] += [float(msg['VBAT'])] node['timestamps'] += [datetime.now()] node['msgID_list'] += [int(msg['msgID'])] node['delay_list'] += [msg['t']] if((int(msg['nID']) != 255) and (msg['f'] == 's')): nodes[int(msg['nID'])-1]['state'] = int(msg['state']) active_nodes = sum(node[\"state\"] == 1 for node in nodes) window.Element('_ACTIVENODES_').update(value=str(active_nodes)) nodes[nidx]['last_activity'] = 'state update' + ' at ' + dt_string if(nidx == window.Element('_LIST_').get_indexes()[0]): updateTabs(nidx) if((int(msg['nID']) != 255) and (msg['f'] == 'u')): nodes[nidx]['last_activity'] = str(nodes[nidx]['sensors'][int(msg['sID'])-1]['name']) + ' with value: ' + msg['sVal'] + ' at ' + dt_string window.Element('_LIST_').update(set_to_index=nidx) window.Element('_STATUSTAB_').update(title='Node ' + msg['nID'] + ' Status') window.Element('_STATSTAB_').update(title='Node ' + msg['nID'] + ' Info') nodes[nidx]['sensors'][int(msg['sID'])-1]['last_activity'] = dt_string nodes[nidx]['sensors'][int(msg['sID'])-1]['state'] = msg['sVal'] nodes[int(msg['nID'])-1]['state'] = 1 active_nodes = sum(node[\"state\"] == 1 for node in nodes) window.Element('_ACTIVENODES_').update(value=str(active_nodes)) updateTabs(nidx) if((int(msg['nID']) != 255) and (msg['f'] == 'a')): nodes[nidx]['last_activity'] = str(nodes[nidx]['actuators'][int(msg['actID'])-1]['name']) + ' with value: ' + msg['actVal'] + ' at ' + dt_string window.Element('_LIST_').update(set_to_index=nidx) window.Element('_STATUSTAB_').update(title='Node ' + msg['nID'] + ' Status') window.Element('_STATSTAB_').update(title='Node ' + msg['nID'] + ' Info') nodes[nidx]['actuators'][int(msg['actID'])-1]['last_activity'] = dt_string nodes[nidx]['actuators'][int(msg['actID'])-1]['state'] = msg['actVal'] nodes[int(msg['nID'])-1]['state'] = 1 active_nodes = sum(node[\"state\"] == 1 for node in nodes) window.Element('_ACTIVENODES_').update(value=str(active_nodes)) if(nidx == window.Element('_LIST_').get_indexes()[0]): updateTabs(nidx) except: continue #print(\"ERROR reading from serial!!\") sc_thread = threading.Thread(target=serial_comm) nt_thread = threading.Thread(target=network_test) def main(): global active_nodes active_nodes = 0 global total_nodes global ser global nodes global stop_threads stop_threads = False with open(\"../config/wsn_config.yaml\", \"r\") as stream: try: config = yaml.safe_load(stream) except yaml.YAMLError as exc: print(exc) gateways = config['wsn_config']['gateways'] for i in range(len(gateways)): gateways_data = { 'state': 0 } gateways[i] = {**gateways[i], **gateways_data} nodes = config['wsn_config']['nodes'] node_data = { 'state': 0, 'last_activity': '', 'packets_sent':0, 'packets_received':0, 'avg_rssi': 0, 'avg_snr': 0, 'battery': 0, 'timestamps': list(), 'rssi_list': list(), 'snr_list': list(), 'battery_list': list(), 'msgID_list': list(), 'delay_list': list(), 'rssi_plot_canvas': None, 'snr_plot_canvas': None } sensors_data = { 'last_activity': '', 'state': None } actuators_data = { 'last_activity': '', 'state': None } for i in range(len(nodes)): for j in range(len(nodes[i]['sensors'])): nodes[i]['sensors'][j] = {**nodes[i]['sensors'][j], **sensors_data} for j in range(len(nodes[i]['actuators'])): nodes[i]['actuators'][j] = {**nodes[i]['actuators'][j], **actuators_data} nodes[i] = {**nodes[i], **node_data} total_nodes = len(nodes) try: ser = serial.Serial(gateways[0]['serial_port'], 9600, timeout=1) except: print(\"Serial port not available!\") return sc_thread.start() gui() stop_threads = True sc_thread.join() #nt_thread.join() ser.close() return 0 if __name__ == \"__main__\": main() Updated on 2022-09-09 at 17:40:17 +0000","title":"/sensor_network/network_manager/src/network_manager.py"},{"location":"Network_Manager/Files/network__manager_8py/#sensor_networknetwork_managersrcnetwork_managerpy","text":"","title":"/sensor_network/network_manager/src/network_manager.py"},{"location":"Network_Manager/Files/network__manager_8py/#namespaces","text":"Name network_manager","title":"Namespaces"},{"location":"Network_Manager/Files/network__manager_8py/#source-code","text":"#!/usr/bin/env python3 import serial from parse import parse import threading import PySimpleGUI as sg import json from datetime import datetime import numpy as np import matplotlib.pyplot as plt from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg plt.rcParams.update({'font.size': 6}) import yaml import csv import time # Global variables declaration. maxNum = 5 gateway_status = \"Offline\" _VARS = {'rssi_canvas': None, 'snr_canvas': None, 'dl_msgs': { 'timestamps': list(), 'nodeID': list(), 'msgID': list(), 'delay': list(), }} def network_test(): runs = 50 msg_delay = 10 print('Starting test!') for i in range(runs): global stop_threads for node in nodes: if stop_threads: return data = 's,' + str(node['id']) send_dl_msg(data) #print(datetime.now(), data) time.sleep(msg_delay) print('Test finished!') def draw_figure(canvas, figure): figure_canvas_agg = FigureCanvasTkAgg(figure, canvas) figure_canvas_agg.draw_idle() figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1) return figure_canvas_agg def send_dl_msg(data): data = bytes(data, encoding='utf-8') ser.write(data) ser.write(bytes(\"\\n\", encoding='utf-8')) ser.flush() def export_data(path): #print(path) with open(path, 'w', newline='') as csvfile: writer = csv.writer(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL) for node in nodes: for i in range(len(node['timestamps'])): writer.writerow([node['timestamps'][i], node['delay_list'][i], node['msgID_list'][i], node['id'], node['rssi_list'][i], node['snr_list'][i], node['battery_list'][i], '0']) for i in range(len(_VARS['dl_msgs']['timestamps'])): writer.writerow([_VARS['dl_msgs']['timestamps'][i], _VARS['dl_msgs']['delay'][i], _VARS['dl_msgs']['msgID'][i], _VARS['dl_msgs']['nodeID'][i], 0, 0, 0, '1']) print('Data exported!') #timestamp, nodeID, rssi, snr, battery, DL/UL #if DL we only care about timestamp and nodeID # set up custom commands for DLMSG: test1, test2 -> execute predetermined tests and save data def gui(): sg.theme('BrownBlue') global active_nodes global nodes global total_nodes node_keys = {'Node ' + str(node['id']): node for node in nodes} sensor_pane_layout = [ sg.Column([ [sg.Text('Sensor ID:', background_color='white', text_color='black'), sg.Text('id', background_color='white', text_color='black', key='_SID'+str(i)+'_')], [sg.Text('Sensor Name:', background_color='white', text_color='black'), sg.Text('name', background_color='white', text_color='black', key='_SNAME'+str(i)+'_')], [sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('never', background_color='white', text_color='black', key='_SLA'+str(i)+'_')], [sg.Text('State:', background_color='white', text_color='black'), sg.Text('unknown', background_color='white', text_color='black', key='_SSTATE'+str(i)+'_')], ], expand_y = True, background_color='white', key='_SCOL'+str(i)+'_', visible=False) for i in range(maxNum)] actuator_pane_layout = [ sg.Column([ [sg.Text('Actuator ID:', background_color='white', text_color='black'), sg.Text('id', background_color='white', text_color='black', key='_AID'+str(i)+'_')], [sg.Text('Actuator Name:', background_color='white', text_color='black'), sg.Text('name', background_color='white', text_color='black', key='_ANAME'+str(i)+'_')], [sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('never', background_color='white', text_color='black', key='_ALA'+str(i)+'_')], [sg.Text('State:', background_color='white', text_color='black'), sg.Text('unknown', background_color='white', text_color='black', key='_ASTATE'+str(i)+'_')], [sg.Button('ON', key='_AON'+str(i)+'_'),sg.Button('OFF', key='_AOFF'+str(i)+'_')], ], expand_y = True, background_color='white', key='_ACOL'+str(i)+'_', visible=False) for i in range(maxNum)] status_tab_layout = [ [ sg.Text('Node State:', background_color='white', text_color='black'), sg.Text('Offline', key='_NSTATE_', background_color='white', text_color='red') ], [ sg.Text('Node Location:', background_color='white', text_color='black'), sg.Text('', key='_NLOCATION_', background_color='white', text_color='black') ], [ sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('None', key='_NLASTACTIVITY_', background_color='white', text_color='black') ], [ sg.Text('Sensors:', background_color='white', text_color='black'), ], [ sg.Column( layout=[sensor_pane_layout], key='_SENSORSPANE_', scrollable = True, size = (None, 110), expand_x=True) ], [ sg.Text('Actuators:', background_color='white', text_color='black'), ], [ sg.Column( layout=[actuator_pane_layout], key='_ACTUATORSPANE_', scrollable = True, size = (None, 145), expand_x=True) ] ] info_tab_layout = [ [ sg.Text('Packets sent:', background_color='white', text_color='black'), sg.Text('0', key='_PACKETSSENT_', background_color='white', text_color='black') ], #[ # sg.Text('Packets received:', background_color='white', text_color='black'), # sg.Text('0', key='_PACKETSRECEIVED_', background_color='white', text_color='black') #], [ sg.Text('Average RSSI:', background_color='white', text_color='black'), sg.Text('', key='_AVGRSSI_', background_color='white', text_color='black') ], [ sg.Text('Average SNR:', background_color='white', text_color='black'), sg.Text('', key='_AVGSNR_', background_color='white', text_color='black') ], [ sg.Text('Battery Level (V):', background_color='white', text_color='black'), sg.Text('', key='_BAT_', background_color='white', text_color='black') ], [ sg.Column(layout = [ [ sg.Frame(layout = [[sg.Canvas(key='rssi_canvas', background_color=sg.theme_background_color())]], title = \"RSSI vs Packet\", size=(250,250)), sg.Frame(layout = [[sg.Canvas(key='snr_canvas', background_color=sg.theme_background_color())]], title = \"SNR vs Packet\", size=(250,250)) ] ], scrollable=False, expand_x = True, expand_y = True) ] ] layout = [ [ sg.Text('Active Nodes:'), sg.Text(str(active_nodes), key='_ACTIVENODES_'), sg.Text('/'), sg.Text( str(total_nodes), key='_TOTALNODES_') ], [ sg.Text('Gateway Status:'), sg.Text(gateway_status, key='_GATEWAYSTATUS_', text_color='red'), sg.Push(), sg.Text('Boot time:'), sg.Text('', key='_BOOTTIME_') ], [sg.Text('Send Downlink Message'), sg.InputText(key='_DLMSG_'), sg.Button('Send')], [sg.HorizontalSeparator()], [ sg.Listbox(values=list(node_keys.keys()), size=(15, 27), key='_LIST_', enable_events=True, select_mode='LISTBOX_SELECT_MODE_SINGLE', default_values=['Node 1']), sg.VerticalSeparator(), sg.TabGroup([ [sg.Tab(title='Node 1 Status', key='_STATUSTAB_', background_color='white', layout = status_tab_layout)], [sg.Tab(title='Node 1 Stats', key='_STATSTAB_', background_color='white', layout = info_tab_layout)] ], tab_location='topleft', size=(600,None), selected_background_color='white', tab_background_color=sg.theme_background_color(), selected_title_color=sg.theme_background_color(), title_color='white' ) ], [sg.Output(size=(119,8))], [ sg.Button('Rescan Network', key='_RSNET_'), sg.Button('Start Test', key='_TEST_'), sg.InputText(visible=False, enable_events=True, key='export_data_path'), sg.FileSaveAs('Export data', key='_EXPORT_', file_types=(('CSV', '.csv'),)), sg.Push(), sg.Button('Exit') ] ] global window window = sg.Window('Sensor Network Manager', layout, finalize=True) for i in range(len(nodes)): plt.figure(num=0) plt.plot([],[],'.k') #nodes[i]['rssi_plot_canvas'] = FigureCanvasTkAgg(plt.figure(num=0), window.Element('rssi_canvas').TKCanvas) _VARS['rssi_canvas'] = FigureCanvasTkAgg(plt.figure(num=0), window.Element('rssi_canvas').TKCanvas) #nodes[i]['rssi_plot_canvas'].get_tk_widget().hide() nodes[i]['rssi_list'] = list() plt.figure(num=1) plt.plot([],[],'.k') #nodes[i]['snr_plot_canvas'] = FigureCanvasTkAgg(plt.figure(num=1), window.Element('snr_canvas').TKCanvas) _VARS['snr_canvas'] = FigureCanvasTkAgg(plt.figure(num=1), window.Element('snr_canvas').TKCanvas) nodes[i]['snr_list'] = list() nodes[i]['timestamps'] = list() nodes[i]['battery_list'] = list() nodes[i]['msgID_list'] = list() nodes[i]['delay_list'] = list() while True: event, values = window.read(timeout = 200) if event == sg.WIN_CLOSED or event == 'Exit': break if event == '_TEST_': global nt_thread nt_thread.start() if event == 'export_data_path': path = values['export_data_path'] export_data(path) if event == 'Send' and len(values['_DLMSG_']): data = values['_DLMSG_'] send_dl_msg(data) window.Element('_DLMSG_').update(value=\"\") if event == '_LIST_' and len(values['_LIST_']): r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) idx = int(r[0])-1 window.Element('_STATUSTAB_').update(title='Node ' + str(idx+1) + ' Status') window.Element('_STATSTAB_').update(title='Node ' + str(idx+1) + ' Stats') updateTabs(idx) if event == '_RSNET_': active_nodes = 0 window.Element('_ACTIVENODES_').update(value=str(active_nodes)) for i in range(len(nodes)): nodes[i][\"state\"] = 0 r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) idx = int(r[0])-1 #updateTabs(idx) send_dl_msg(\"s,-1\\n\") if '_AON' in event: r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) nID = int(r[0]) r = parse(\"_AON{}_\", str(event)) actID = int(r[0]) actID = nodes[nID-1]['actuators'][actID]['id'] data = 'c,' + str(nID) + ',' + str(actID) + ',1' send_dl_msg(data) if '_AOFF' in event: r = parse(\"[\\'Node {}\\']\", str(values['_LIST_'])) nID = int(r[0]) r = parse(\"_AOFF{}_\", str(event)) actID = int(r[0]) actID = nodes[nID-1]['actuators'][actID]['id'] data = 'c,' + str(nID) + ',' + str(actID) + ',0' send_dl_msg(data) window.refresh() window.close() firstTime = True def updateTabs(idx): global nodes global window window.Element('_NSTATE_').update(value='Online' if int(nodes[idx]['state']) else 'Offline', text_color='green' if int(nodes[idx]['state']) else 'red') window.Element('_NLASTACTIVITY_').update(value=str(nodes[idx]['last_activity'])) window.Element('_NLOCATION_').update(value=str(nodes[idx]['location'])) window.Element('_PACKETSSENT_').update(value=str(nodes[idx]['packets_sent'])) #window.Element('_PACKETSRECEIVED_').update(value=str(nodes[idx]['packets_received'])) window.Element('_PACKETSSENT_').update(value=str(nodes[idx]['packets_sent'])) window.Element('_AVGRSSI_').update(value=str(nodes[idx]['avg_rssi'])) window.Element('_AVGSNR_').update(value=str(nodes[idx]['avg_snr'])) window.Element('_BAT_').update(value=str(nodes[idx]['battery'])) # \\\\ -------- PYPLOT -------- // if(len(nodes[idx]['rssi_list'])>0): #nodes[idx]['rssi_plot_canvas'].get_tk_widget().forget() _VARS['rssi_canvas'].get_tk_widget().forget() plt.figure(num=0) plt.clf() plt.plot(range(1,len(nodes[idx]['rssi_list'])+1), nodes[idx]['rssi_list'], 'bo-', linewidth=0.5, markersize=3) plt.xticks(np.arange(1, len(nodes[idx]['rssi_list'])+1)) plt.ylim(-120, 20) #nodes[idx]['rssi_plot_canvas'] = draw_figure(window.Element('rssi_canvas').TKCanvas, plt.figure(num=0)) _VARS['rssi_canvas'] = draw_figure(window.Element('rssi_canvas').TKCanvas, plt.figure(num=0)) #nodes[idx]['snr_plot_canvas'].get_tk_widget().forget() _VARS['snr_canvas'].get_tk_widget().forget() plt.figure(num=1) plt.clf() plt.plot(range(1,len(nodes[idx]['snr_list'])+1), nodes[idx]['snr_list'], 'bo-', linewidth=0.5, markersize=3) plt.xticks(np.arange(1, len(nodes[idx]['snr_list'])+1)) plt.ylim(-15, 15) #nodes[idx]['snr_plot_canvas'] = draw_figure(window.Element('snr_canvas').TKCanvas, plt.figure(num=1)) _VARS['snr_canvas'] = draw_figure(window.Element('snr_canvas').TKCanvas, plt.figure(num=1)) # \\\\ -------- PYPLOT -------- // for i in range(maxNum): if i < len(nodes[idx]['sensors']): window.Element('_SCOL'+str(i)+'_').update(visible=True) window.Element('_SID'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['id'])) window.Element('_SNAME'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['name'])) window.Element('_SLA'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['last_activity'])) window.Element('_SSTATE'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['state'])) else: window.Element('_SCOL'+str(i)+'_').update(visible=False) for i in range(maxNum): if i < len(nodes[idx]['actuators']): window.Element('_ACOL'+str(i)+'_').update(visible=True) window.Element('_AID'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['id'])) window.Element('_ANAME'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['name'])) window.Element('_ALA'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['last_activity'])) window.Element('_ASTATE'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['state'])) else: window.Element('_ACOL'+str(i)+'_').update(visible=False) window.Element('_SENSORSPANE_').contents_changed() window.Element('_ACTUATORSPANE_').contents_changed() def serial_comm(): while True: global stop_threads if stop_threads: break global nodes global window line = ser.readline() line = line.decode('utf-8', \"ignore\") if(len(line) > 4): line = line.strip('rm').strip('\\n').rstrip() if line == \"Startup complete\": window.Element('_GATEWAYSTATUS_').update(value=line, text_color='#42cf68') window.Element('_BOOTTIME_').update(value=datetime.now().strftime(\"%d/%m/%Y %H:%M:%S\")) else: try: print(datetime.now(), line) msg = json.loads(line) if(msg['f'] == 'd'): _VARS['dl_msgs']['nodeID'].append(msg['nID']) _VARS['dl_msgs']['timestamps'].append(datetime.now()) _VARS['dl_msgs']['msgID'].append(msg['msgID']) _VARS['dl_msgs']['delay'].append(msg['t']) else: nidx = int(msg['nID'])-1 now = datetime.now() dt_string = now.strftime(\"%d/%m/%Y %H:%M:%S\") if(int(msg['RSSI']) != 0): nodes[int(msg['nID'])-1]['packets_sent'] += 1 t_packets = nodes[int(msg['nID'])-1]['packets_sent'] + nodes[int(msg['nID'])-1]['packets_received'] avg_rssi = float(nodes[int(msg['nID'])-1]['avg_rssi']) * float(t_packets-1)/t_packets + float(msg['RSSI']) * float(1/t_packets) avg_snr = nodes[int(msg['nID'])-1]['avg_snr'] * float(t_packets-1)/t_packets + float(msg['SNR']) * float(1/t_packets) bat = float(msg['VBAT']) nodes[int(msg['nID'])-1]['avg_rssi'] = round(avg_rssi, 2) nodes[int(msg['nID'])-1]['avg_snr'] = round(avg_snr, 2) nodes[int(msg['nID'])-1]['battery'] = round(bat, 1) for node in nodes: if int(node['id']) == int(msg['nID']): node['rssi_list'] += [float(msg['RSSI'])] node['snr_list'] += [float(msg['SNR'])] node['battery_list'] += [float(msg['VBAT'])] node['timestamps'] += [datetime.now()] node['msgID_list'] += [int(msg['msgID'])] node['delay_list'] += [msg['t']] if((int(msg['nID']) != 255) and (msg['f'] == 's')): nodes[int(msg['nID'])-1]['state'] = int(msg['state']) active_nodes = sum(node[\"state\"] == 1 for node in nodes) window.Element('_ACTIVENODES_').update(value=str(active_nodes)) nodes[nidx]['last_activity'] = 'state update' + ' at ' + dt_string if(nidx == window.Element('_LIST_').get_indexes()[0]): updateTabs(nidx) if((int(msg['nID']) != 255) and (msg['f'] == 'u')): nodes[nidx]['last_activity'] = str(nodes[nidx]['sensors'][int(msg['sID'])-1]['name']) + ' with value: ' + msg['sVal'] + ' at ' + dt_string window.Element('_LIST_').update(set_to_index=nidx) window.Element('_STATUSTAB_').update(title='Node ' + msg['nID'] + ' Status') window.Element('_STATSTAB_').update(title='Node ' + msg['nID'] + ' Info') nodes[nidx]['sensors'][int(msg['sID'])-1]['last_activity'] = dt_string nodes[nidx]['sensors'][int(msg['sID'])-1]['state'] = msg['sVal'] nodes[int(msg['nID'])-1]['state'] = 1 active_nodes = sum(node[\"state\"] == 1 for node in nodes) window.Element('_ACTIVENODES_').update(value=str(active_nodes)) updateTabs(nidx) if((int(msg['nID']) != 255) and (msg['f'] == 'a')): nodes[nidx]['last_activity'] = str(nodes[nidx]['actuators'][int(msg['actID'])-1]['name']) + ' with value: ' + msg['actVal'] + ' at ' + dt_string window.Element('_LIST_').update(set_to_index=nidx) window.Element('_STATUSTAB_').update(title='Node ' + msg['nID'] + ' Status') window.Element('_STATSTAB_').update(title='Node ' + msg['nID'] + ' Info') nodes[nidx]['actuators'][int(msg['actID'])-1]['last_activity'] = dt_string nodes[nidx]['actuators'][int(msg['actID'])-1]['state'] = msg['actVal'] nodes[int(msg['nID'])-1]['state'] = 1 active_nodes = sum(node[\"state\"] == 1 for node in nodes) window.Element('_ACTIVENODES_').update(value=str(active_nodes)) if(nidx == window.Element('_LIST_').get_indexes()[0]): updateTabs(nidx) except: continue #print(\"ERROR reading from serial!!\") sc_thread = threading.Thread(target=serial_comm) nt_thread = threading.Thread(target=network_test) def main(): global active_nodes active_nodes = 0 global total_nodes global ser global nodes global stop_threads stop_threads = False with open(\"../config/wsn_config.yaml\", \"r\") as stream: try: config = yaml.safe_load(stream) except yaml.YAMLError as exc: print(exc) gateways = config['wsn_config']['gateways'] for i in range(len(gateways)): gateways_data = { 'state': 0 } gateways[i] = {**gateways[i], **gateways_data} nodes = config['wsn_config']['nodes'] node_data = { 'state': 0, 'last_activity': '', 'packets_sent':0, 'packets_received':0, 'avg_rssi': 0, 'avg_snr': 0, 'battery': 0, 'timestamps': list(), 'rssi_list': list(), 'snr_list': list(), 'battery_list': list(), 'msgID_list': list(), 'delay_list': list(), 'rssi_plot_canvas': None, 'snr_plot_canvas': None } sensors_data = { 'last_activity': '', 'state': None } actuators_data = { 'last_activity': '', 'state': None } for i in range(len(nodes)): for j in range(len(nodes[i]['sensors'])): nodes[i]['sensors'][j] = {**nodes[i]['sensors'][j], **sensors_data} for j in range(len(nodes[i]['actuators'])): nodes[i]['actuators'][j] = {**nodes[i]['actuators'][j], **actuators_data} nodes[i] = {**nodes[i], **node_data} total_nodes = len(nodes) try: ser = serial.Serial(gateways[0]['serial_port'], 9600, timeout=1) except: print(\"Serial port not available!\") return sc_thread.start() gui() stop_threads = True sc_thread.join() #nt_thread.join() ser.close() return 0 if __name__ == \"__main__\": main() Updated on 2022-09-09 at 17:40:17 +0000","title":"Source code"},{"location":"Network_Manager/Files/stats__plotter_8m/","text":"/sensor_network/network_manager/src/stats_plotter.m Functions Name indxs ( a , 1 ) end if ( nodeID ( i ) ==2) indxs ( b , 2 ) indxs ( c , 3 ) end if ( dir ( i ) ==1) indxs_dl ( d , 1 ) indxs_dl ( e , 2 ) indxs_dl ( f , 3 ) end end avg_rssi (1 ) avg_rssi (2 ) avg_rssi (3 ) avg_snr (1 ) avg_snr (2 ) avg_snr (3 ) Calculate Average Delay Time avg_delay (1 ) avg_delay (2 ) avg_delay (3 ) packet_loss Plot RSSI vs Time figure () hold on line ('Color' , 'LineWidth' , lineThickness ) scatter ( time ( indxs (1: a , 1)) , rssi ( indxs (1: a , 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: b , 2)) , rssi ( indxs (1: b , 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: c , 3)) , rssi ( indxs (1: c , 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) ylim () xlim () xtickformat ('mm:ss' ) legend ('Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1 Packets' , 'Node 2 Packets' , 'Node 3 Packets' , 'Location' , 'best' ) xlabel (\"Time (mm:ss)\" ) ylabel (\"RSSI (dB)\" ) hold on line ('Color' ) scatter ( time ( indxs (1: a , 1)) , snr ( indxs (1: a , 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: b , 2)) , snr ( indxs (1: b , 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: c , 3)) , snr ( indxs (1: c , 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) ylabel (\"SNR (dB)\" ) scatter ( time ( indxs (1: a , 1)) , delay ( indxs (1: a , 1)) - delay ( indxs_dl (1: d , 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: b , 2)) , delay ( indxs (1: b , 2)) - delay ( indxs_dl (1: e , 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: c , 3)) , delay ( indxs (1: c , 3)) - delay ( indxs_dl (1: f , 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) legend ('Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1' , 'Node 2' , 'Node 3' , 'Location' , 'best' ) ylabel (\"Packet Delay (ms)\" ) Attributes Name close all Array t delay msgID nodeID rssi snr battery dir n a b c d e f time ul_packets dl_packets Plot Settings markerSize lineThickness Claculate Average RSSI and SNR and AvgDelay for i avg_delay_m mID avg_delay_m Calculate Package Loss packet_loss grid on Functions Documentation function indxs indxs( a , 1 ) function if end if( nodeID(i) ==2 ) function indxs indxs( b , 2 ) function indxs indxs( c , 3 ) function if end if( dir(i) ==1 ) function indxs_dl indxs_dl( d , 1 ) function indxs_dl indxs_dl( e , 2 ) function indxs_dl indxs_dl( f , 3 ) function avg_rssi end end avg_rssi( 1 ) function avg_rssi avg_rssi( 2 ) function avg_rssi avg_rssi( 3 ) function avg_snr avg_snr( 1 ) function avg_snr avg_snr( 2 ) function avg_snr avg_snr( 3 ) function avg_delay Calculate Average Delay Time avg_delay( 1 ) function avg_delay avg_delay( 2 ) function avg_delay avg_delay( 3 ) function figure packet_loss Plot RSSI vs Time figure() function line hold on line( 'Color' , 'LineWidth' , lineThickness ) function scatter scatter( time(indxs(1:a, 1)) , rssi(indxs(1:a, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function scatter scatter( time(indxs(1:b, 2)) , rssi(indxs(1:b, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function scatter scatter( time(indxs(1:c, 3)) , rssi(indxs(1:c, 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function ylim ylim() function xlim xlim() function xtickformat xtickformat( 'mm:ss' ) function legend legend( 'Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1 Packets' , 'Node 2 Packets' , 'Node 3 Packets' , 'Location' , 'best' ) function xlabel xlabel( \"Time (mm:ss)\" ) function ylabel ylabel( \"RSSI (dB)\" ) function line hold on line( 'Color' ) function scatter scatter( time(indxs(1:a, 1)) , snr(indxs(1:a, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function scatter scatter( time(indxs(1:b, 2)) , snr(indxs(1:b, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function scatter scatter( time(indxs(1:c, 3)) , snr(indxs(1:c, 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function ylabel ylabel( \"SNR (dB)\" ) function scatter scatter( time(indxs(1:a, 1)) , delay(indxs(1:a, 1)) -delay(indxs_dl(1:d, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function scatter scatter( time(indxs(1:b, 2)) , delay(indxs(1:b, 2)) -delay(indxs_dl(1:e, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function scatter scatter( time(indxs(1:c, 3)) , delay(indxs(1:c, 3)) -delay(indxs_dl(1:f, 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) function legend legend( 'Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1' , 'Node 2' , 'Node 3' , 'Location' , 'best' ) function ylabel ylabel( \"Packet Delay (ms)\" ) Attributes Documentation variable all close all; variable Array Array =readtable('basic50.csv'); variable t t = datetime(table2array(Array(:,1)),'InputFormat','yyyy-MM-dd HH:mm:ss.SSSSSS'); variable delay delay = table2array(Array(:, 2)); variable msgID msgID = table2array(Array(:, 3)); variable nodeID nodeID = table2array(Array(:, 4)); variable rssi rssi = table2array(Array(:, 5)); variable snr snr = table2array(Array(:, 6)); variable battery battery = table2array(Array(:, 7)); variable dir dir = table2array(Array(:, 8)); variable n n = size(msgID); variable a a =0; variable b b =0; variable c c =0; variable d d =0; variable e e =0; variable f f =0; variable time time = t-t(1); variable ul_packets ul_packets = 0; variable dl_packets dl_packets = 0; variable markerSize Plot Settings markerSize = 15; variable lineThickness lineThickness = 0.0567; variable i Claculate Average RSSI and SNR and AvgDelay for i =1:nif(dir(i) == 0) if(nodeID(i) == 1) a = a+1; variable avg_delay_m avg_delay_m = mean(avg_delay); variable mID mID = max(msgID); variable packet_loss avg_delay_m Calculate Package Loss packet_loss = 1 - ul_packets/dl_packets; variable on grid on; Source code close all; Array=readtable('basic50.csv'); t = datetime(table2array(Array(:,1)),'InputFormat','yyyy-MM-dd HH:mm:ss.SSSSSS'); delay = table2array(Array(:, 2)); msgID = table2array(Array(:, 3)); nodeID = table2array(Array(:, 4)); rssi = table2array(Array(:, 5)); snr = table2array(Array(:, 6)); battery = table2array(Array(:, 7)); dir = table2array(Array(:, 8)); n = size(msgID); n = n(1); a=0;b=0;c=0;d=0;e=0;f=0; time = t-t(1); ul_packets = 0; dl_packets = 0; % Plot Settings markerSize = 15; lineThickness = 0.0567; %% Claculate Average RSSI and SNR and AvgDelay for i=1:n if(dir(i) == 0) if(nodeID(i) == 1) a = a+1; indxs(a,1) = i; end if (nodeID(i) == 2) b = b+1; indxs(b,2) = i; end if (nodeID(i) == 3) c = c+1; indxs(c,3) = i; end ul_packets = ul_packets + 1; end if(dir(i) == 1) if(nodeID(i) == 1) d = d+1; indxs_dl(d,1) = i; end if (nodeID(i) == 2) e = e+1; indxs_dl(e,2) = i; end if (nodeID(i) == 3) f = f+1; indxs_dl(f,3) = i; end dl_packets = dl_packets + 1; end end avg_rssi(1) = mean(rssi(indxs(1:a,1))); avg_rssi(2) = mean(rssi(indxs(1:b,2))); avg_rssi(3) = mean(rssi(indxs(1:c,3))); avg_snr(1) = mean(snr(indxs(1:a,1))); avg_snr(2) = mean(snr(indxs(1:b,2))); avg_snr(3) = mean(snr(indxs(1:c,3))); %% Calculate Average Delay Time avg_delay(1) = mean(delay(indxs(1:a,1))-delay(indxs_dl(1:d,1))); avg_delay(2) = mean(delay(indxs(1:b,2))-delay(indxs_dl(1:e,2))); avg_delay(3) = mean(delay(indxs(1:c,3))-delay(indxs_dl(1:f,3))); avg_delay_m = mean(avg_delay); mID = max(msgID); avg_delay_m %% Calculate Package Loss packet_loss = 1 - ul_packets/dl_packets; packet_loss %% Plot RSSI vs Time figure(); hold on line([min(time),max(time)],[avg_rssi(1),avg_rssi(1)], 'Color', [0 0.4470 0.7410], 'LineWidth',lineThickness); line([min(time),max(time)],[avg_rssi(2),avg_rssi(2)], 'Color', [0.8500 0.3250 0.0980], 'LineWidth',lineThickness); line([min(time),max(time)],[avg_rssi(3),avg_rssi(3)], 'Color', [0.9290 0.6940 0.1250], 'LineWidth',lineThickness); scatter(time(indxs(1:a,1)), rssi(indxs(1:a,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],... 'MarkerFaceColor',[0 0.4470 0.7410],... 'LineWidth',1); scatter(time(indxs(1:b,2)), rssi(indxs(1:b,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],... 'MarkerFaceColor',[0.8500 0.3250 0.0980],... 'LineWidth',1); scatter(time(indxs(1:c,3)), rssi(indxs(1:c,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],... 'MarkerFaceColor',[0.9290 0.6940 0.1250],... 'LineWidth',1); grid on; ylim([-90 -30]); xlim([time(1) time(a+b+c)]); xtickformat('mm:ss'); legend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1 Packets', 'Node 2 Packets', 'Node 3 Packets','Location','best'); xlabel(\"Time (mm:ss)\"); ylabel(\"RSSI (dB)\"); %% Plot SNR vs Time figure(); hold on line([min(time),max(time)],[avg_snr(1),avg_snr(1)], 'Color', [0 0.4470 0.7410]); line([min(time),max(time)],[avg_snr(2),avg_snr(2)], 'Color', [0.8500 0.3250 0.0980]); line([min(time),max(time)],[avg_snr(3),avg_snr(3)], 'Color', [0.9290 0.6940 0.1250]); scatter(time(indxs(1:a,1)), snr(indxs(1:a,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],... 'MarkerFaceColor',[0 0.4470 0.7410],... 'LineWidth',1); scatter(time(indxs(1:b,2)), snr(indxs(1:b,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],... 'MarkerFaceColor',[0.8500 0.3250 0.0980],... 'LineWidth',1); scatter(time(indxs(1:c,3)), snr(indxs(1:c,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],... 'MarkerFaceColor',[0.9290 0.6940 0.1250],... 'LineWidth',1); grid on; ylim([6 13]); xlim([time(1) time(a+b+c)]); xtickformat('mm:ss'); legend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1 Packets', 'Node 2 Packets', 'Node 3 Packets','Location','best'); xlabel(\"Time (mm:ss)\"); ylabel(\"SNR (dB)\"); %% Plot Delays figure(); hold on line([min(time),max(time)],[avg_delay(1),avg_delay(1)], 'Color', [0 0.4470 0.7410]); line([min(time),max(time)],[avg_delay(2),avg_delay(2)], 'Color', [0.8500 0.3250 0.0980]); line([min(time),max(time)],[avg_delay(3),avg_delay(3)], 'Color', [0.9290 0.6940 0.1250]); scatter(time(indxs(1:a,1)), delay(indxs(1:a,1))-delay(indxs_dl(1:d,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],... 'MarkerFaceColor',[0 0.4470 0.7410],... 'LineWidth',1); scatter(time(indxs(1:b,2)), delay(indxs(1:b,2))-delay(indxs_dl(1:e,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],... 'MarkerFaceColor',[0.8500 0.3250 0.0980],... 'LineWidth',1); scatter(time(indxs(1:c,3)), delay(indxs(1:c,3))-delay(indxs_dl(1:f,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],... 'MarkerFaceColor',[0.9290 0.6940 0.1250],... 'LineWidth',1); grid on; ylim([195 210]); xlim([time(1) time(a+b+c)]); xtickformat('mm:ss'); legend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1', 'Node 2', 'Node 3','Location','best'); xlabel(\"Time (mm:ss)\"); ylabel(\"Packet Delay (ms)\"); Updated on 2022-09-09 at 17:40:17 +0000","title":"/sensor_network/network_manager/src/stats_plotter.m"},{"location":"Network_Manager/Files/stats__plotter_8m/#sensor_networknetwork_managersrcstats_plotterm","text":"","title":"/sensor_network/network_manager/src/stats_plotter.m"},{"location":"Network_Manager/Files/stats__plotter_8m/#functions","text":"Name indxs ( a , 1 ) end if ( nodeID ( i ) ==2) indxs ( b , 2 ) indxs ( c , 3 ) end if ( dir ( i ) ==1) indxs_dl ( d , 1 ) indxs_dl ( e , 2 ) indxs_dl ( f , 3 ) end end avg_rssi (1 ) avg_rssi (2 ) avg_rssi (3 ) avg_snr (1 ) avg_snr (2 ) avg_snr (3 ) Calculate Average Delay Time avg_delay (1 ) avg_delay (2 ) avg_delay (3 ) packet_loss Plot RSSI vs Time figure () hold on line ('Color' , 'LineWidth' , lineThickness ) scatter ( time ( indxs (1: a , 1)) , rssi ( indxs (1: a , 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: b , 2)) , rssi ( indxs (1: b , 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: c , 3)) , rssi ( indxs (1: c , 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) ylim () xlim () xtickformat ('mm:ss' ) legend ('Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1 Packets' , 'Node 2 Packets' , 'Node 3 Packets' , 'Location' , 'best' ) xlabel (\"Time (mm:ss)\" ) ylabel (\"RSSI (dB)\" ) hold on line ('Color' ) scatter ( time ( indxs (1: a , 1)) , snr ( indxs (1: a , 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: b , 2)) , snr ( indxs (1: b , 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: c , 3)) , snr ( indxs (1: c , 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) ylabel (\"SNR (dB)\" ) scatter ( time ( indxs (1: a , 1)) , delay ( indxs (1: a , 1)) - delay ( indxs_dl (1: d , 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: b , 2)) , delay ( indxs (1: b , 2)) - delay ( indxs_dl (1: e , 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter ( time ( indxs (1: c , 3)) , delay ( indxs (1: c , 3)) - delay ( indxs_dl (1: f , 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) legend ('Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1' , 'Node 2' , 'Node 3' , 'Location' , 'best' ) ylabel (\"Packet Delay (ms)\" )","title":"Functions"},{"location":"Network_Manager/Files/stats__plotter_8m/#attributes","text":"Name close all Array t delay msgID nodeID rssi snr battery dir n a b c d e f time ul_packets dl_packets Plot Settings markerSize lineThickness Claculate Average RSSI and SNR and AvgDelay for i avg_delay_m mID avg_delay_m Calculate Package Loss packet_loss grid on","title":"Attributes"},{"location":"Network_Manager/Files/stats__plotter_8m/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs","text":"indxs( a , 1 )","title":"function indxs"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if","text":"end if( nodeID(i) ==2 )","title":"function if"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_1","text":"indxs( b , 2 )","title":"function indxs"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_2","text":"indxs( c , 3 )","title":"function indxs"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if_1","text":"end if( dir(i) ==1 )","title":"function if"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_dl","text":"indxs_dl( d , 1 )","title":"function indxs_dl"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_dl_1","text":"indxs_dl( e , 2 )","title":"function indxs_dl"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_dl_2","text":"indxs_dl( f , 3 )","title":"function indxs_dl"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_rssi","text":"end end avg_rssi( 1 )","title":"function avg_rssi"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_rssi_1","text":"avg_rssi( 2 )","title":"function avg_rssi"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_rssi_2","text":"avg_rssi( 3 )","title":"function avg_rssi"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_snr","text":"avg_snr( 1 )","title":"function avg_snr"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_snr_1","text":"avg_snr( 2 )","title":"function avg_snr"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_snr_2","text":"avg_snr( 3 )","title":"function avg_snr"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_delay","text":"Calculate Average Delay Time avg_delay( 1 )","title":"function avg_delay"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_delay_1","text":"avg_delay( 2 )","title":"function avg_delay"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_delay_2","text":"avg_delay( 3 )","title":"function avg_delay"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-figure","text":"packet_loss Plot RSSI vs Time figure()","title":"function figure"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-line","text":"hold on line( 'Color' , 'LineWidth' , lineThickness )","title":"function line"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter","text":"scatter( time(indxs(1:a, 1)) , rssi(indxs(1:a, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_1","text":"scatter( time(indxs(1:b, 2)) , rssi(indxs(1:b, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_2","text":"scatter( time(indxs(1:c, 3)) , rssi(indxs(1:c, 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylim","text":"ylim()","title":"function ylim"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-xlim","text":"xlim()","title":"function xlim"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-xtickformat","text":"xtickformat( 'mm:ss' )","title":"function xtickformat"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-legend","text":"legend( 'Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1 Packets' , 'Node 2 Packets' , 'Node 3 Packets' , 'Location' , 'best' )","title":"function legend"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-xlabel","text":"xlabel( \"Time (mm:ss)\" )","title":"function xlabel"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylabel","text":"ylabel( \"RSSI (dB)\" )","title":"function ylabel"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-line_1","text":"hold on line( 'Color' )","title":"function line"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_3","text":"scatter( time(indxs(1:a, 1)) , snr(indxs(1:a, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_4","text":"scatter( time(indxs(1:b, 2)) , snr(indxs(1:b, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_5","text":"scatter( time(indxs(1:c, 3)) , snr(indxs(1:c, 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylabel_1","text":"ylabel( \"SNR (dB)\" )","title":"function ylabel"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_6","text":"scatter( time(indxs(1:a, 1)) , delay(indxs(1:a, 1)) -delay(indxs_dl(1:d, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_7","text":"scatter( time(indxs(1:b, 2)) , delay(indxs(1:b, 2)) -delay(indxs_dl(1:e, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_8","text":"scatter( time(indxs(1:c, 3)) , delay(indxs(1:c, 3)) -delay(indxs_dl(1:f, 3)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 )","title":"function scatter"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-legend_1","text":"legend( 'Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1' , 'Node 2' , 'Node 3' , 'Location' , 'best' )","title":"function legend"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylabel_2","text":"ylabel( \"Packet Delay (ms)\" )","title":"function ylabel"},{"location":"Network_Manager/Files/stats__plotter_8m/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-all","text":"close all;","title":"variable all"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-array","text":"Array =readtable('basic50.csv');","title":"variable Array"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-t","text":"t = datetime(table2array(Array(:,1)),'InputFormat','yyyy-MM-dd HH:mm:ss.SSSSSS');","title":"variable t"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-delay","text":"delay = table2array(Array(:, 2));","title":"variable delay"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-msgid","text":"msgID = table2array(Array(:, 3));","title":"variable msgID"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-nodeid","text":"nodeID = table2array(Array(:, 4));","title":"variable nodeID"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-rssi","text":"rssi = table2array(Array(:, 5));","title":"variable rssi"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-snr","text":"snr = table2array(Array(:, 6));","title":"variable snr"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-battery","text":"battery = table2array(Array(:, 7));","title":"variable battery"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-dir","text":"dir = table2array(Array(:, 8));","title":"variable dir"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-n","text":"n = size(msgID);","title":"variable n"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-a","text":"a =0;","title":"variable a"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-b","text":"b =0;","title":"variable b"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-c","text":"c =0;","title":"variable c"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-d","text":"d =0;","title":"variable d"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-e","text":"e =0;","title":"variable e"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-f","text":"f =0;","title":"variable f"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-time","text":"time = t-t(1);","title":"variable time"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-ul_packets","text":"ul_packets = 0;","title":"variable ul_packets"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-dl_packets","text":"dl_packets = 0;","title":"variable dl_packets"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-markersize","text":"Plot Settings markerSize = 15;","title":"variable markerSize"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-linethickness","text":"lineThickness = 0.0567;","title":"variable lineThickness"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-i","text":"Claculate Average RSSI and SNR and AvgDelay for i =1:nif(dir(i) == 0) if(nodeID(i) == 1) a = a+1;","title":"variable i"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-avg_delay_m","text":"avg_delay_m = mean(avg_delay);","title":"variable avg_delay_m"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-mid","text":"mID = max(msgID);","title":"variable mID"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-packet_loss","text":"avg_delay_m Calculate Package Loss packet_loss = 1 - ul_packets/dl_packets;","title":"variable packet_loss"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-on","text":"grid on;","title":"variable on"},{"location":"Network_Manager/Files/stats__plotter_8m/#source-code","text":"close all; Array=readtable('basic50.csv'); t = datetime(table2array(Array(:,1)),'InputFormat','yyyy-MM-dd HH:mm:ss.SSSSSS'); delay = table2array(Array(:, 2)); msgID = table2array(Array(:, 3)); nodeID = table2array(Array(:, 4)); rssi = table2array(Array(:, 5)); snr = table2array(Array(:, 6)); battery = table2array(Array(:, 7)); dir = table2array(Array(:, 8)); n = size(msgID); n = n(1); a=0;b=0;c=0;d=0;e=0;f=0; time = t-t(1); ul_packets = 0; dl_packets = 0; % Plot Settings markerSize = 15; lineThickness = 0.0567; %% Claculate Average RSSI and SNR and AvgDelay for i=1:n if(dir(i) == 0) if(nodeID(i) == 1) a = a+1; indxs(a,1) = i; end if (nodeID(i) == 2) b = b+1; indxs(b,2) = i; end if (nodeID(i) == 3) c = c+1; indxs(c,3) = i; end ul_packets = ul_packets + 1; end if(dir(i) == 1) if(nodeID(i) == 1) d = d+1; indxs_dl(d,1) = i; end if (nodeID(i) == 2) e = e+1; indxs_dl(e,2) = i; end if (nodeID(i) == 3) f = f+1; indxs_dl(f,3) = i; end dl_packets = dl_packets + 1; end end avg_rssi(1) = mean(rssi(indxs(1:a,1))); avg_rssi(2) = mean(rssi(indxs(1:b,2))); avg_rssi(3) = mean(rssi(indxs(1:c,3))); avg_snr(1) = mean(snr(indxs(1:a,1))); avg_snr(2) = mean(snr(indxs(1:b,2))); avg_snr(3) = mean(snr(indxs(1:c,3))); %% Calculate Average Delay Time avg_delay(1) = mean(delay(indxs(1:a,1))-delay(indxs_dl(1:d,1))); avg_delay(2) = mean(delay(indxs(1:b,2))-delay(indxs_dl(1:e,2))); avg_delay(3) = mean(delay(indxs(1:c,3))-delay(indxs_dl(1:f,3))); avg_delay_m = mean(avg_delay); mID = max(msgID); avg_delay_m %% Calculate Package Loss packet_loss = 1 - ul_packets/dl_packets; packet_loss %% Plot RSSI vs Time figure(); hold on line([min(time),max(time)],[avg_rssi(1),avg_rssi(1)], 'Color', [0 0.4470 0.7410], 'LineWidth',lineThickness); line([min(time),max(time)],[avg_rssi(2),avg_rssi(2)], 'Color', [0.8500 0.3250 0.0980], 'LineWidth',lineThickness); line([min(time),max(time)],[avg_rssi(3),avg_rssi(3)], 'Color', [0.9290 0.6940 0.1250], 'LineWidth',lineThickness); scatter(time(indxs(1:a,1)), rssi(indxs(1:a,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],... 'MarkerFaceColor',[0 0.4470 0.7410],... 'LineWidth',1); scatter(time(indxs(1:b,2)), rssi(indxs(1:b,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],... 'MarkerFaceColor',[0.8500 0.3250 0.0980],... 'LineWidth',1); scatter(time(indxs(1:c,3)), rssi(indxs(1:c,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],... 'MarkerFaceColor',[0.9290 0.6940 0.1250],... 'LineWidth',1); grid on; ylim([-90 -30]); xlim([time(1) time(a+b+c)]); xtickformat('mm:ss'); legend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1 Packets', 'Node 2 Packets', 'Node 3 Packets','Location','best'); xlabel(\"Time (mm:ss)\"); ylabel(\"RSSI (dB)\"); %% Plot SNR vs Time figure(); hold on line([min(time),max(time)],[avg_snr(1),avg_snr(1)], 'Color', [0 0.4470 0.7410]); line([min(time),max(time)],[avg_snr(2),avg_snr(2)], 'Color', [0.8500 0.3250 0.0980]); line([min(time),max(time)],[avg_snr(3),avg_snr(3)], 'Color', [0.9290 0.6940 0.1250]); scatter(time(indxs(1:a,1)), snr(indxs(1:a,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],... 'MarkerFaceColor',[0 0.4470 0.7410],... 'LineWidth',1); scatter(time(indxs(1:b,2)), snr(indxs(1:b,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],... 'MarkerFaceColor',[0.8500 0.3250 0.0980],... 'LineWidth',1); scatter(time(indxs(1:c,3)), snr(indxs(1:c,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],... 'MarkerFaceColor',[0.9290 0.6940 0.1250],... 'LineWidth',1); grid on; ylim([6 13]); xlim([time(1) time(a+b+c)]); xtickformat('mm:ss'); legend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1 Packets', 'Node 2 Packets', 'Node 3 Packets','Location','best'); xlabel(\"Time (mm:ss)\"); ylabel(\"SNR (dB)\"); %% Plot Delays figure(); hold on line([min(time),max(time)],[avg_delay(1),avg_delay(1)], 'Color', [0 0.4470 0.7410]); line([min(time),max(time)],[avg_delay(2),avg_delay(2)], 'Color', [0.8500 0.3250 0.0980]); line([min(time),max(time)],[avg_delay(3),avg_delay(3)], 'Color', [0.9290 0.6940 0.1250]); scatter(time(indxs(1:a,1)), delay(indxs(1:a,1))-delay(indxs_dl(1:d,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],... 'MarkerFaceColor',[0 0.4470 0.7410],... 'LineWidth',1); scatter(time(indxs(1:b,2)), delay(indxs(1:b,2))-delay(indxs_dl(1:e,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],... 'MarkerFaceColor',[0.8500 0.3250 0.0980],... 'LineWidth',1); scatter(time(indxs(1:c,3)), delay(indxs(1:c,3))-delay(indxs_dl(1:f,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],... 'MarkerFaceColor',[0.9290 0.6940 0.1250],... 'LineWidth',1); grid on; ylim([195 210]); xlim([time(1) time(a+b+c)]); xtickformat('mm:ss'); legend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1', 'Node 2', 'Node 3','Location','best'); xlabel(\"Time (mm:ss)\"); ylabel(\"Packet Delay (ms)\"); Updated on 2022-09-09 at 17:40:17 +0000","title":"Source code"},{"location":"Network_Manager/Modules/","text":"Modules Updated on 2022-09-09 at 17:40:17 +0000","title":"Modules"},{"location":"Network_Manager/Modules/#modules","text":"Updated on 2022-09-09 at 17:40:17 +0000","title":"Modules"},{"location":"Network_Manager/Namespaces/","text":"Namespaces namespace network_manager Updated on 2022-09-09 at 17:40:17 +0000","title":"Namespaces"},{"location":"Network_Manager/Namespaces/#namespaces","text":"namespace network_manager Updated on 2022-09-09 at 17:40:17 +0000","title":"Namespaces"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/","text":"network_manager More... Functions Name def network_test () Function that runs a test on the network. def draw_figure (canvas canvas, figure figure) Function that draws a plot onto a figure. def send_dl_msg (data data) Function that sends a downlink message to the gateway through the serial connection. def export_data (path path) Function to export the gathered data onto a .csv file. def gui () Function responsible for all the GUI initialization and layout. def updateTabs (idx idx) Function that updates the GUI. def serial_comm () Function that handles the received messages from the gateway through the serial communication. def main () Main function. Attributes Name int maxNum string gateway_status bool firstTime sc_thread nt_thread Detailed Description Allows communication with the gateway to monitor and control the network This is a python application with a gui designed to interface with the wireless sensor network through the serial port connected to the gateway. It allows for downlink messages to be sent, uplink messages to be received and monitoring of the network. Additionally, network tests can be run and the data monitored can be exported for further analysis Functions Documentation function network_test def network_test() Function that runs a test on the network. function draw_figure def draw_figure( canvas canvas, figure figure ) Function that draws a plot onto a figure. function send_dl_msg def send_dl_msg( data data ) Function that sends a downlink message to the gateway through the serial connection. function export_data def export_data( path path ) Function to export the gathered data onto a .csv file. function gui def gui() Function responsible for all the GUI initialization and layout. function updateTabs def updateTabs( idx idx ) Function that updates the GUI. function serial_comm def serial_comm() Function that handles the received messages from the gateway through the serial communication. function main def main() Main function. Attributes Documentation variable maxNum int maxNum = 5; variable gateway_status string gateway_status = \"Offline\"; variable firstTime bool firstTime = True; variable sc_thread sc_thread = threading.Thread(target=serial_comm); variable nt_thread nt_thread = threading.Thread(target=network_test); Updated on 2022-09-09 at 17:40:17 +0000","title":"network_manager"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#network_manager","text":"More...","title":"network_manager"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#functions","text":"Name def network_test () Function that runs a test on the network. def draw_figure (canvas canvas, figure figure) Function that draws a plot onto a figure. def send_dl_msg (data data) Function that sends a downlink message to the gateway through the serial connection. def export_data (path path) Function to export the gathered data onto a .csv file. def gui () Function responsible for all the GUI initialization and layout. def updateTabs (idx idx) Function that updates the GUI. def serial_comm () Function that handles the received messages from the gateway through the serial communication. def main () Main function.","title":"Functions"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#attributes","text":"Name int maxNum string gateway_status bool firstTime sc_thread nt_thread","title":"Attributes"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#detailed-description","text":"Allows communication with the gateway to monitor and control the network This is a python application with a gui designed to interface with the wireless sensor network through the serial port connected to the gateway. It allows for downlink messages to be sent, uplink messages to be received and monitoring of the network. Additionally, network tests can be run and the data monitored can be exported for further analysis","title":"Detailed Description"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-network_test","text":"def network_test() Function that runs a test on the network.","title":"function network_test"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-draw_figure","text":"def draw_figure( canvas canvas, figure figure ) Function that draws a plot onto a figure.","title":"function draw_figure"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-send_dl_msg","text":"def send_dl_msg( data data ) Function that sends a downlink message to the gateway through the serial connection.","title":"function send_dl_msg"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-export_data","text":"def export_data( path path ) Function to export the gathered data onto a .csv file.","title":"function export_data"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-gui","text":"def gui() Function responsible for all the GUI initialization and layout.","title":"function gui"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-updatetabs","text":"def updateTabs( idx idx ) Function that updates the GUI.","title":"function updateTabs"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-serial_comm","text":"def serial_comm() Function that handles the received messages from the gateway through the serial communication.","title":"function serial_comm"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-main","text":"def main() Main function.","title":"function main"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-maxnum","text":"int maxNum = 5;","title":"variable maxNum"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-gateway_status","text":"string gateway_status = \"Offline\";","title":"variable gateway_status"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-firsttime","text":"bool firstTime = True;","title":"variable firstTime"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-sc_thread","text":"sc_thread = threading.Thread(target=serial_comm);","title":"variable sc_thread"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-nt_thread","text":"nt_thread = threading.Thread(target=network_test); Updated on 2022-09-09 at 17:40:17 +0000","title":"variable nt_thread"},{"location":"Network_Manager/Pages/","text":"Pages Updated on 2022-09-09 at 17:40:17 +0000","title":"Pages"},{"location":"Network_Manager/Pages/#pages","text":"Updated on 2022-09-09 at 17:40:17 +0000","title":"Pages"},{"location":"Node/Classes/","text":"Classes struct strMsg Data structure that holds the encrypted payload along with other important fields. struct strPayload Data structure that holds the data for all the fields in the payload. Updated on 2022-09-09 at 17:40:11 +0000","title":"Classes"},{"location":"Node/Classes/#classes","text":"struct strMsg Data structure that holds the encrypted payload along with other important fields. struct strPayload Data structure that holds the data for all the fields in the payload. Updated on 2022-09-09 at 17:40:11 +0000","title":"Classes"},{"location":"Node/Classes/structstr_msg/","text":"strMsg Data structure that holds the encrypted payload along with other important fields. #include <comms_protocol.h> Public Attributes Name byte msg byte msgID char flag Public Attributes Documentation variable msg byte msg; variable msgID byte msgID; variable flag char flag; Updated on 2022-09-09 at 17:40:10 +0000","title":"strMsg"},{"location":"Node/Classes/structstr_msg/#strmsg","text":"Data structure that holds the encrypted payload along with other important fields. #include <comms_protocol.h>","title":"strMsg"},{"location":"Node/Classes/structstr_msg/#public-attributes","text":"Name byte msg byte msgID char flag","title":"Public Attributes"},{"location":"Node/Classes/structstr_msg/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Node/Classes/structstr_msg/#variable-msg","text":"byte msg;","title":"variable msg"},{"location":"Node/Classes/structstr_msg/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Node/Classes/structstr_msg/#variable-flag","text":"char flag; Updated on 2022-09-09 at 17:40:10 +0000","title":"variable flag"},{"location":"Node/Classes/structstr_payload/","text":"strPayload Data structure that holds the data for all the fields in the payload. #include <comms_protocol.h> Public Attributes Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR Public Attributes Documentation variable nodeID byte nodeID; variable sensorID byte sensorID; variable msgID byte msgID; variable flag char flag; variable sensorVal byte sensorVal; variable RSSI int RSSI; variable SNR float SNR; Updated on 2022-09-09 at 17:40:10 +0000","title":"strPayload"},{"location":"Node/Classes/structstr_payload/#strpayload","text":"Data structure that holds the data for all the fields in the payload. #include <comms_protocol.h>","title":"strPayload"},{"location":"Node/Classes/structstr_payload/#public-attributes","text":"Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR","title":"Public Attributes"},{"location":"Node/Classes/structstr_payload/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"Node/Classes/structstr_payload/#variable-nodeid","text":"byte nodeID;","title":"variable nodeID"},{"location":"Node/Classes/structstr_payload/#variable-sensorid","text":"byte sensorID;","title":"variable sensorID"},{"location":"Node/Classes/structstr_payload/#variable-msgid","text":"byte msgID;","title":"variable msgID"},{"location":"Node/Classes/structstr_payload/#variable-flag","text":"char flag;","title":"variable flag"},{"location":"Node/Classes/structstr_payload/#variable-sensorval","text":"byte sensorVal;","title":"variable sensorVal"},{"location":"Node/Classes/structstr_payload/#variable-rssi","text":"int RSSI;","title":"variable RSSI"},{"location":"Node/Classes/structstr_payload/#variable-snr","text":"float SNR; Updated on 2022-09-09 at 17:40:10 +0000","title":"variable SNR"},{"location":"Node/Examples/","text":"Examples Updated on 2022-09-09 at 17:40:11 +0000","title":"Examples"},{"location":"Node/Examples/#examples","text":"Updated on 2022-09-09 at 17:40:11 +0000","title":"Examples"},{"location":"Node/Files/","text":"Files dir /sensor_network/node/node_definitions file /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. file /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. file /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. file /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. file /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file node.ino Node script - send sensor data to gateway and receive commands from gateway. file node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Updated on 2022-09-09 at 17:40:11 +0000","title":"Files"},{"location":"Node/Files/#files","text":"dir /sensor_network/node/node_definitions file /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. file /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. file /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. file /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. file /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. file node.ino Node script - send sensor data to gateway and receive commands from gateway. file node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Updated on 2022-09-09 at 17:40:11 +0000","title":"Files"},{"location":"Node/Files/comms__protocol_8cpp/","text":"comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More... Functions Name cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Attributes Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt Detailed Description Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Functions Documentation function msg_q cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION ) function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void function encrypt byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message function decryptMsg char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b function sendAck void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void function sendStatus void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void function setActState void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void function sendSensorData void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV. function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void Attributes Documentation variable currMsg int currMsg = -1; variable count int count = 0; variable prevMil unsigned long prevMil; variable prevMilSU unsigned long prevMilSU; variable VBAT float VBAT = 1.0; variable msgCount int msgCount = 0; variable ctxt aes256_context ctxt; Source code #include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMil; unsigned long prevMilSU; float VBAT = 1.0; int msgCount = 0; cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.enableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); LoRa.disableInvertIQ(); } void LoRa_sendMessage(byte *message) { LoRa_txMode(); // set tx mode LoRa.beginPacket(); // start packet LoRa.write(netID); LoRa.write(nodeID); //LoRa.print(message); // add payload LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); // finish packet and send it LoRa_rxMode(); } byte *encrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; static byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; aes256_done(&ctxt); } char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); //static char m[MAX_PAYLOAD_SIZE+1]; //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID) { String enc; char payload[MAX_PAYLOAD_SIZE]; char encP[MAX_ENC_PAYLOAD_SIZE]; byte l = (byte)MAX_PAYLOAD_SIZE; Msg msg; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add ack to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); msg.msgID = msgID; msg.flag = 'a'; msg_q.push(&msg); } void sendStatus(byte msgID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msg.msgID = msgID; byte l = (byte) MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add status to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); // Add msg to msg queue msg.flag = 's'; msg_q.push(&msg); } void setActState(int ID, int val) { Serial.print(\"Set actuator: \"); Serial.print(ID); Serial.print(\" with value: \"); Serial.println(val); digitalWrite(actPin[ID], val); } void sendSensorData(byte sensorID, byte sensorVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; byte l = MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif Serial.println(VBAT); int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; // Add msg to msg queue msg.flag = 'u'; msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Serial.print(\"send msg: \"); //Serial.println(msg.msg); LoRa_sendMessage(msg.msg); if ((msg.flag == 's') || (msg.flag == 'a')){ msg_q.drop(); currMsg = -1; } } else { Serial.print(\"Failed to send msg with id: \"); Serial.println(msg.msgID); msg_q.drop(); currMsg = -1; } prevMil = currentMillis; } } void onReceive(int packetSize){ byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; char buffer2[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available() && i<MAX_ENC_PAYLOAD_SIZE) { //Serial.println(LoRa.peek(), HEX); buffer1[i] = (char)LoRa.read(); //message += (char)LoRa.read(); i++; } Serial.println(\"msg\"); //Serial.println(message.length()); //Serial.println(MAX_ENC_PAYLOAD_SIZE); //Serial.println(rNetID == netID); if (rNetID == netID) { Serial.println(\"New msg received\"); //int j = message.length() / ENC_BLOCK_SIZE; //int h = message.length() / (1 * j); byte len; Payload p; if (rnID == BROADCAST_ID) aes256_init(&ctxt,(uint8_t *) keyBroadcast); else aes256_init(&ctxt,(uint8_t *) key); //for (int i = 0; i < j; i++) { // if (i == 0) // strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); // else // strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); //} strcpy(buffer2, decryptMsg(buffer1)); aes256_done(&ctxt); buffer2[6] = '\\0'; Serial.println(buffer2); if(sscanf(buffer2, \"%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal) == 6){ Serial.println(p.flag); Msg msg; msg_q.peek(&msg); if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) { if (p.flag == 'a') { if (p.msgID == msg.msgID) { Serial.print(\"Message with ID: \"); Serial.print(p.msgID); Serial.println(\" delivered!\"); msg_q.drop(); } } else if (p.flag == 's') { Serial.print(\"received msg with id: \"); Serial.println(p.msgID); sendStatus(p.msgID); } else if (p.flag == 'c') { // Set actuator value and send ack setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1)); sendAck(p.msgID); } } } } } Updated on 2022-09-09 at 17:40:11 +0000","title":"comms_protocol.cpp"},{"location":"Node/Files/comms__protocol_8cpp/#comms_protocolcpp","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. More...","title":"comms_protocol.cpp"},{"location":"Node/Files/comms__protocol_8cpp/#functions","text":"Name cppQueue msg_q (sizeof( Msg ) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin (int a, int b) returns the minimum value between two integers void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary.","title":"Functions"},{"location":"Node/Files/comms__protocol_8cpp/#attributes","text":"Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt","title":"Attributes"},{"location":"Node/Files/comms__protocol_8cpp/#detailed-description","text":"Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/comms__protocol_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Node/Files/comms__protocol_8cpp/#function-msg_q","text":"cppQueue msg_q( sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION )","title":"function msg_q"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void","title":"function LoRa_sendMessage"},{"location":"Node/Files/comms__protocol_8cpp/#function-encrypt","text":"byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message","title":"function encrypt"},{"location":"Node/Files/comms__protocol_8cpp/#function-decryptmsg","text":"char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg"},{"location":"Node/Files/comms__protocol_8cpp/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendack","text":"void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void","title":"function sendAck"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendstatus","text":"void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void","title":"function sendStatus"},{"location":"Node/Files/comms__protocol_8cpp/#function-setactstate","text":"void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void","title":"function setActState"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendsensordata","text":"void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.","title":"function sendSensorData"},{"location":"Node/Files/comms__protocol_8cpp/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Node/Files/comms__protocol_8cpp/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void","title":"function onReceive"},{"location":"Node/Files/comms__protocol_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/comms__protocol_8cpp/#variable-currmsg","text":"int currMsg = -1;","title":"variable currMsg"},{"location":"Node/Files/comms__protocol_8cpp/#variable-count","text":"int count = 0;","title":"variable count"},{"location":"Node/Files/comms__protocol_8cpp/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Node/Files/comms__protocol_8cpp/#variable-prevmilsu","text":"unsigned long prevMilSU;","title":"variable prevMilSU"},{"location":"Node/Files/comms__protocol_8cpp/#variable-vbat","text":"float VBAT = 1.0;","title":"variable VBAT"},{"location":"Node/Files/comms__protocol_8cpp/#variable-msgcount","text":"int msgCount = 0;","title":"variable msgCount"},{"location":"Node/Files/comms__protocol_8cpp/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Node/Files/comms__protocol_8cpp/#source-code","text":"#include \"comms_protocol.h\" int currMsg = -1; int count = 0; unsigned long prevMil; unsigned long prevMilSU; float VBAT = 1.0; int msgCount = 0; cppQueue msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION); aes256_context ctxt; void LoRa_rxMode() { LoRa.enableInvertIQ(); LoRa.receive(); } void LoRa_txMode() { LoRa.idle(); LoRa.disableInvertIQ(); } void LoRa_sendMessage(byte *message) { LoRa_txMode(); // set tx mode LoRa.beginPacket(); // start packet LoRa.write(netID); LoRa.write(nodeID); //LoRa.print(message); // add payload LoRa.write(message, MAX_ENC_PAYLOAD_SIZE); LoRa.endPacket(false); // finish packet and send it LoRa_rxMode(); } byte *encrypt(char msg[MAX_PAYLOAD_SIZE]) { String enc = \"\"; aes256_init(&ctxt,(uint8_t *) key); const char * p = msg; static byte plain [BLOCK_SIZE]; memset (plain, 0, BLOCK_SIZE); // ensure trailing zeros memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE)); aes256_encrypt_ecb(&ctxt, plain); return plain; aes256_done(&ctxt); } char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]) { static uint8_t data[MAX_PAYLOAD_SIZE+1]; memcpy(data, msg, MAX_PAYLOAD_SIZE+1); //static char m[MAX_PAYLOAD_SIZE+1]; //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1); aes256_decrypt_ecb(&ctxt, (uint8_t *)data); return (char *)data; } int mymin(int a, int b){ if (a>b) return b; return a; } void sendAck(byte msgID) { String enc; char payload[MAX_PAYLOAD_SIZE]; char encP[MAX_ENC_PAYLOAD_SIZE]; byte l = (byte)MAX_PAYLOAD_SIZE; Msg msg; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add ack to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); msg.msgID = msgID; msg.flag = 'a'; msg_q.push(&msg); } void sendStatus(byte msgID) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msg.msgID = msgID; byte l = (byte) MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; Serial.print(\"add status to queue: \"); Serial.println(payload); //Serial.print(\"enc msg: \"); //Serial.println(msg.msg); // Add msg to msg queue msg.flag = 's'; msg_q.push(&msg); } void setActState(int ID, int val) { Serial.print(\"Set actuator: \"); Serial.print(ID); Serial.print(\" with value: \"); Serial.println(val); digitalWrite(actPin[ID], val); } void sendSensorData(byte sensorID, byte sensorVal) { Msg msg; String enc; char payload[MAX_PAYLOAD_SIZE]; msgCount ++; if (msgCount == 0) msgCount ++; msg.msgID = (byte) msgCount; byte l = MAX_PAYLOAD_SIZE; #if defined(ESP32) VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1; #endif Serial.println(VBAT); int a = VBAT; int b = VBAT*10-a*10; sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1); //enc = splitAndEncrypt(payload); //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE); byte *plain = encrypt(payload); memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE); msg.msg[MAX_PAYLOAD_SIZE] = '\\0'; // Add msg to msg queue msg.flag = 'u'; msg_q.push(&msg); } void getMsgFromQueueAndSend(unsigned long currentMillis) { if (!msg_q.isEmpty()) { Msg msg; msg_q.peek(&msg); if (currMsg == msg.msgID) count ++; else count = 0; currMsg = msg.msgID; if (count < MAX_N_RETRY) { Serial.print(\"send msg: \"); //Serial.println(msg.msg); LoRa_sendMessage(msg.msg); if ((msg.flag == 's') || (msg.flag == 'a')){ msg_q.drop(); currMsg = -1; } } else { Serial.print(\"Failed to send msg with id: \"); Serial.println(msg.msgID); msg_q.drop(); currMsg = -1; } prevMil = currentMillis; } } void onReceive(int packetSize){ byte rNetID = LoRa.read(); byte rnID = LoRa.read(); char buffer1[MAX_ENC_PAYLOAD_SIZE]; char buffer2[MAX_ENC_PAYLOAD_SIZE]; String message = \"\"; int i=0; while (LoRa.available() && i<MAX_ENC_PAYLOAD_SIZE) { //Serial.println(LoRa.peek(), HEX); buffer1[i] = (char)LoRa.read(); //message += (char)LoRa.read(); i++; } Serial.println(\"msg\"); //Serial.println(message.length()); //Serial.println(MAX_ENC_PAYLOAD_SIZE); //Serial.println(rNetID == netID); if (rNetID == netID) { Serial.println(\"New msg received\"); //int j = message.length() / ENC_BLOCK_SIZE; //int h = message.length() / (1 * j); byte len; Payload p; if (rnID == BROADCAST_ID) aes256_init(&ctxt,(uint8_t *) keyBroadcast); else aes256_init(&ctxt,(uint8_t *) key); //for (int i = 0; i < j; i++) { // if (i == 0) // strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); // else // strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE))); //} strcpy(buffer2, decryptMsg(buffer1)); aes256_done(&ctxt); buffer2[6] = '\\0'; Serial.println(buffer2); if(sscanf(buffer2, \"%c%c%c%c%c%c\", &p.nodeID, &p.msgID, &len, &p.flag, &p.sensorID, &p.sensorVal) == 6){ Serial.println(p.flag); Msg msg; msg_q.peek(&msg); if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) { if (p.flag == 'a') { if (p.msgID == msg.msgID) { Serial.print(\"Message with ID: \"); Serial.print(p.msgID); Serial.println(\" delivered!\"); msg_q.drop(); } } else if (p.flag == 's') { Serial.print(\"received msg with id: \"); Serial.println(p.msgID); sendStatus(p.msgID); } else if (p.flag == 'c') { // Set actuator value and send ack setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1)); sendAck(p.msgID); } } } } } Updated on 2022-09-09 at 17:40:11 +0000","title":"Source code"},{"location":"Node/Files/comms__protocol_8h/","text":"comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More... Classes Name struct strPayload Data structure that holds the data for all the fields in the payload. struct strMsg Data structure that holds the encrypted payload along with other important fields. Types Name typedef struct strPayload Payload Data structure that holds the data for all the fields in the payload. typedef struct strMsg Msg Data structure that holds the encrypted payload along with other important fields. Functions Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone () byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. int mymin (int a, int b) returns the minimum value between two integers Attributes Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt Defines Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID Detailed Description Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Types Documentation typedef Payload typedef struct strPayload Payload; Data structure that holds the data for all the fields in the payload. typedef Msg typedef struct strMsg Msg; Data structure that holds the encrypted payload along with other important fields. Functions Documentation function LoRa_rxMode void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void function LoRa_txMode void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void function LoRa_sendMessage void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void function decryptMsg char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message function onReceive void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void function onTxDone void onTxDone() function encrypt byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message function sendSensorData void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV. function getMsgFromQueueAndSend void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void function sendStatus void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void function sendAck void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void function setActState void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void function mymin int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b Attributes Documentation variable keyBroadcast const uint8_t keyBroadcast = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; variable frequency const long frequency = 868E6; variable txPower const int txPower = 14; variable spreadingFactor const int spreadingFactor = 7; variable signalBandwidth const long signalBandwidth = 125E3; variable codingRateDenominator const int codingRateDenominator = 5; variable currMsg int currMsg; variable count int count; variable prevMil unsigned long prevMil; variable prevMilSU unsigned long prevMilSU; variable msgCount int msgCount; variable msg_q cppQueue msg_q; variable ctxt aes256_context ctxt; Macros Documentation define IMPLEMENTATION #define IMPLEMENTATION FIFO define MAX_N_RETRY #define MAX_N_RETRY 3 define TIMEOUT_INTERVAL #define TIMEOUT_INTERVAL 1000 define MAX_QUEUE_SIZE #define MAX_QUEUE_SIZE 5 define BLOCK_SIZE #define BLOCK_SIZE 16 define MAX_PAYLOAD_SIZE #define MAX_PAYLOAD_SIZE 16 define ENC_BLOCK_SIZE #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) define MAX_ENC_PAYLOAD_SIZE #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 define MAX_MSG_ID #define MAX_MSG_ID 256 define STATUS_UPDATE_INTERVAL #define STATUS_UPDATE_INTERVAL 60000 define BROADCAST_ID #define BROADCAST_ID 0xFF Source code #ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include <cppQueue.h> #include <aes256.h> #include \"node_definitions.h\" #define IMPLEMENTATION FIFO // LoRa msg payload settings #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 1000 #define MAX_QUEUE_SIZE 5 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define MAX_MSG_ID 256 #define STATUS_UPDATE_INTERVAL 60000 #define BROADCAST_ID 0xFF // Broadcast Encryption key const uint8_t keyBroadcast[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte msgID; char flag; byte sensorVal; int RSSI; float SNR; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; } Msg; extern int currMsg; extern int count; extern unsigned long prevMil; extern unsigned long prevMilSU; extern int msgCount; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message); char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); byte *encrypt(char msg[MAX_PAYLOAD_SIZE]); void sendSensorData(byte sensorID, byte sensorVal); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatus(byte msgID); void sendAck(byte msgID); void setActState(int ID, int val); int mymin(int a, int b); #endif Updated on 2022-09-09 at 17:40:11 +0000","title":"comms_protocol.h"},{"location":"Node/Files/comms__protocol_8h/#comms_protocolh","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. More...","title":"comms_protocol.h"},{"location":"Node/Files/comms__protocol_8h/#classes","text":"Name struct strPayload Data structure that holds the data for all the fields in the payload. struct strMsg Data structure that holds the encrypted payload along with other important fields.","title":"Classes"},{"location":"Node/Files/comms__protocol_8h/#types","text":"Name typedef struct strPayload Payload Data structure that holds the data for all the fields in the payload. typedef struct strMsg Msg Data structure that holds the encrypted payload along with other important fields.","title":"Types"},{"location":"Node/Files/comms__protocol_8h/#functions","text":"Name void LoRa_rxMode () Sets the LoRa radio to receive mode. void LoRa_txMode () Sets the LoRa radio to transmit mode. void LoRa_sendMessage (byte * message) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg (char msg[MAX_PAYLOAD_SIZE+1]) Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive (int packetSize) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone () byte * encrypt (char msg[MAX_PAYLOAD_SIZE]) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. void sendSensorData (byte sensorID, byte sensorVal) Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend (unsigned long currentMillis) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus (byte msgID) Send an uplink message containing the node status. void sendAck (byte msgID) Send an acknowledge message confirming the reception of an uplink transmission. void setActState (int ID, int val) Sets the state of the relevant actuator with the relevant value. int mymin (int a, int b) returns the minimum value between two integers","title":"Functions"},{"location":"Node/Files/comms__protocol_8h/#attributes","text":"Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt","title":"Attributes"},{"location":"Node/Files/comms__protocol_8h/#defines","text":"Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID","title":"Defines"},{"location":"Node/Files/comms__protocol_8h/#detailed-description","text":"Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/comms__protocol_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"Node/Files/comms__protocol_8h/#typedef-payload","text":"typedef struct strPayload Payload; Data structure that holds the data for all the fields in the payload.","title":"typedef Payload"},{"location":"Node/Files/comms__protocol_8h/#typedef-msg","text":"typedef struct strMsg Msg; Data structure that holds the encrypted payload along with other important fields.","title":"typedef Msg"},{"location":"Node/Files/comms__protocol_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Node/Files/comms__protocol_8h/#function-lora_rxmode","text":"void LoRa_rxMode() Sets the LoRa radio to receive mode. Return : void","title":"function LoRa_rxMode"},{"location":"Node/Files/comms__protocol_8h/#function-lora_txmode","text":"void LoRa_txMode() Sets the LoRa radio to transmit mode. Return : void","title":"function LoRa_txMode"},{"location":"Node/Files/comms__protocol_8h/#function-lora_sendmessage","text":"void LoRa_sendMessage( byte * message ) Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. Parameters : message message to send Return : void","title":"function LoRa_sendMessage"},{"location":"Node/Files/comms__protocol_8h/#function-decryptmsg","text":"char * decryptMsg( char msg[MAX_PAYLOAD_SIZE+1] ) Decrypts a message string using the AES256 algorythm with the corresponding node key. Parameters : msg message string to be decrypted Return : char* an array of characters containing the decrypted message","title":"function decryptMsg"},{"location":"Node/Files/comms__protocol_8h/#function-onreceive","text":"void onReceive( int packetSize ) Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Parameters : packetSize size of the incoming message in bytes Return : void","title":"function onReceive"},{"location":"Node/Files/comms__protocol_8h/#function-ontxdone","text":"void onTxDone()","title":"function onTxDone"},{"location":"Node/Files/comms__protocol_8h/#function-encrypt","text":"byte * encrypt( char msg[MAX_PAYLOAD_SIZE] ) Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. Parameters : msg message array to be decrypted Return : byte* a byte array containing the encrypted message","title":"function encrypt"},{"location":"Node/Files/comms__protocol_8h/#function-sendsensordata","text":"void sendSensorData( byte sensorID, byte sensorVal ) Adds to the message queue an uplink message containing sensor data. Parameters : sensorID ID of the relevant sensor sensorVal value read from the relevant sensor Return : void Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.","title":"function sendSensorData"},{"location":"Node/Files/comms__protocol_8h/#function-getmsgfromqueueandsend","text":"void getMsgFromQueueAndSend( unsigned long currentMillis ) Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. Parameters : currentMillis current time in millisenconds since boot Return : void","title":"function getMsgFromQueueAndSend"},{"location":"Node/Files/comms__protocol_8h/#function-sendstatus","text":"void sendStatus( byte msgID ) Send an uplink message containing the node status. Parameters : msgID ID of the status request message Return : void","title":"function sendStatus"},{"location":"Node/Files/comms__protocol_8h/#function-sendack","text":"void sendAck( byte msgID ) Send an acknowledge message confirming the reception of an uplink transmission. Parameters : msgID ID of the message being acknowledged Return : void","title":"function sendAck"},{"location":"Node/Files/comms__protocol_8h/#function-setactstate","text":"void setActState( int ID, int val ) Sets the state of the relevant actuator with the relevant value. Parameters : ID ID of the relevant actuator val value to which the actuator is set to Return : void","title":"function setActState"},{"location":"Node/Files/comms__protocol_8h/#function-mymin","text":"int mymin( int a, int b ) returns the minimum value between two integers Parameters : a first integer to compare b second integer to compare Return : int the smaller between a and b","title":"function mymin"},{"location":"Node/Files/comms__protocol_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/comms__protocol_8h/#variable-keybroadcast","text":"const uint8_t keyBroadcast = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f };","title":"variable keyBroadcast"},{"location":"Node/Files/comms__protocol_8h/#variable-frequency","text":"const long frequency = 868E6;","title":"variable frequency"},{"location":"Node/Files/comms__protocol_8h/#variable-txpower","text":"const int txPower = 14;","title":"variable txPower"},{"location":"Node/Files/comms__protocol_8h/#variable-spreadingfactor","text":"const int spreadingFactor = 7;","title":"variable spreadingFactor"},{"location":"Node/Files/comms__protocol_8h/#variable-signalbandwidth","text":"const long signalBandwidth = 125E3;","title":"variable signalBandwidth"},{"location":"Node/Files/comms__protocol_8h/#variable-codingratedenominator","text":"const int codingRateDenominator = 5;","title":"variable codingRateDenominator"},{"location":"Node/Files/comms__protocol_8h/#variable-currmsg","text":"int currMsg;","title":"variable currMsg"},{"location":"Node/Files/comms__protocol_8h/#variable-count","text":"int count;","title":"variable count"},{"location":"Node/Files/comms__protocol_8h/#variable-prevmil","text":"unsigned long prevMil;","title":"variable prevMil"},{"location":"Node/Files/comms__protocol_8h/#variable-prevmilsu","text":"unsigned long prevMilSU;","title":"variable prevMilSU"},{"location":"Node/Files/comms__protocol_8h/#variable-msgcount","text":"int msgCount;","title":"variable msgCount"},{"location":"Node/Files/comms__protocol_8h/#variable-msg_q","text":"cppQueue msg_q;","title":"variable msg_q"},{"location":"Node/Files/comms__protocol_8h/#variable-ctxt","text":"aes256_context ctxt;","title":"variable ctxt"},{"location":"Node/Files/comms__protocol_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/comms__protocol_8h/#define-implementation","text":"#define IMPLEMENTATION FIFO","title":"define IMPLEMENTATION"},{"location":"Node/Files/comms__protocol_8h/#define-max_n_retry","text":"#define MAX_N_RETRY 3","title":"define MAX_N_RETRY"},{"location":"Node/Files/comms__protocol_8h/#define-timeout_interval","text":"#define TIMEOUT_INTERVAL 1000","title":"define TIMEOUT_INTERVAL"},{"location":"Node/Files/comms__protocol_8h/#define-max_queue_size","text":"#define MAX_QUEUE_SIZE 5","title":"define MAX_QUEUE_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-block_size","text":"#define BLOCK_SIZE 16","title":"define BLOCK_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-max_payload_size","text":"#define MAX_PAYLOAD_SIZE 16","title":"define MAX_PAYLOAD_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-enc_block_size","text":"#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)","title":"define ENC_BLOCK_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-max_enc_payload_size","text":"#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1","title":"define MAX_ENC_PAYLOAD_SIZE"},{"location":"Node/Files/comms__protocol_8h/#define-max_msg_id","text":"#define MAX_MSG_ID 256","title":"define MAX_MSG_ID"},{"location":"Node/Files/comms__protocol_8h/#define-status_update_interval","text":"#define STATUS_UPDATE_INTERVAL 60000","title":"define STATUS_UPDATE_INTERVAL"},{"location":"Node/Files/comms__protocol_8h/#define-broadcast_id","text":"#define BROADCAST_ID 0xFF","title":"define BROADCAST_ID"},{"location":"Node/Files/comms__protocol_8h/#source-code","text":"#ifndef COMMS_PROTOCOL_H #define COMMS_PROTOCOL_H #include <Arduino.h> #include <SPI.h> #include <LoRa.h> #include <cppQueue.h> #include <aes256.h> #include \"node_definitions.h\" #define IMPLEMENTATION FIFO // LoRa msg payload settings #define MAX_N_RETRY 3 #define TIMEOUT_INTERVAL 1000 #define MAX_QUEUE_SIZE 5 #define BLOCK_SIZE 16 #define MAX_PAYLOAD_SIZE 16 #define ENC_BLOCK_SIZE (1*BLOCK_SIZE) #define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1 #define MAX_MSG_ID 256 #define STATUS_UPDATE_INTERVAL 60000 #define BROADCAST_ID 0xFF // Broadcast Encryption key const uint8_t keyBroadcast[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f }; // LoRa Modem Settings const long frequency = 868E6; const int txPower = 14; const int spreadingFactor = 7; const long signalBandwidth = 125E3; const int codingRateDenominator = 5; typedef struct strPayload { byte nodeID; byte sensorID; byte msgID; char flag; byte sensorVal; int RSSI; float SNR; } Payload; typedef struct strMsg { byte msg[MAX_ENC_PAYLOAD_SIZE]; byte msgID; char flag; } Msg; extern int currMsg; extern int count; extern unsigned long prevMil; extern unsigned long prevMilSU; extern int msgCount; extern cppQueue msg_q; extern aes256_context ctxt; void LoRa_rxMode(); void LoRa_txMode(); void LoRa_sendMessage(byte *message); char *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]); void onReceive(int packetSize); void onTxDone(); byte *encrypt(char msg[MAX_PAYLOAD_SIZE]); void sendSensorData(byte sensorID, byte sensorVal); void getMsgFromQueueAndSend(unsigned long currentMillis); void sendStatus(byte msgID); void sendAck(byte msgID); void setActState(int ID, int val); int mymin(int a, int b); #endif Updated on 2022-09-09 at 17:40:11 +0000","title":"Source code"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/","text":"/sensor_network/node/node_definitions Files Name /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. Updated on 2022-09-09 at 17:40:10 +0000","title":"/sensor_network/node/node_definitions"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/#sensor_networknodenode_definitions","text":"","title":"/sensor_network/node/node_definitions"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/#files","text":"Name /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. Updated on 2022-09-09 at 17:40:10 +0000","title":"Files"},{"location":"Node/Files/node_8ino/","text":"node.ino Node script - send sensor data to gateway and receive commands from gateway. More... Functions Name void setup () Arduino setup function. void loop () Arduino loop function. Detailed Description Node script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022 Functions Documentation function setup void setup() Arduino setup function. Return : void Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode function loop void loop() Arduino loop function. Return : void Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically. Source code #include \"comms_protocol.h\" void setup() { for(int i=0; i<sensN; i++){ pinMode(sensPin[i], INPUT); } for(int i=0; i<actN; i++){ pinMode(actPin[i], OUTPUT); } Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif //LoRa.setTxPower(txPower); //LoRa.setSignalBandwidth(signalBandwidth); //LoRa.setCodingRate4(codingRateDenominator); LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.println(\"LoRa init failed.\"); while (true); } LoRa.setSpreadingFactor(7); LoRa.setCodingRate4(8); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); prevMilSU = millis(); Serial.println(\"Node startup complete\"); sendSensorData(0, 3); } void loop() { unsigned long currentMillis = millis(); // Receive Downlink msg int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Send Uplink msg if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ getMsgFromQueueAndSend(currentMillis); } // Send node status if((currentMillis-prevMilSU) > STATUS_UPDATE_INTERVAL){ byte msgID = random(MAX_MSG_ID); //sendStatus(msgID); prevMilSU = currentMillis; } } Updated on 2022-09-09 at 17:40:11 +0000","title":"node.ino"},{"location":"Node/Files/node_8ino/#nodeino","text":"Node script - send sensor data to gateway and receive commands from gateway. More...","title":"node.ino"},{"location":"Node/Files/node_8ino/#functions","text":"Name void setup () Arduino setup function. void loop () Arduino loop function.","title":"Functions"},{"location":"Node/Files/node_8ino/#detailed-description","text":"Node script - send sensor data to gateway and receive commands from gateway. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-09 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node_8ino/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"Node/Files/node_8ino/#function-setup","text":"void setup() Arduino setup function. Return : void Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode","title":"function setup"},{"location":"Node/Files/node_8ino/#function-loop","text":"void loop() Arduino loop function. Return : void Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically.","title":"function loop"},{"location":"Node/Files/node_8ino/#source-code","text":"#include \"comms_protocol.h\" void setup() { for(int i=0; i<sensN; i++){ pinMode(sensPin[i], INPUT); } for(int i=0; i<actN; i++){ pinMode(actPin[i], OUTPUT); } Serial.begin(BAUD_RATE); #if defined(ESP32) SPI.begin(SCK, MISO, MOSI, SS); #endif //LoRa.setTxPower(txPower); //LoRa.setSignalBandwidth(signalBandwidth); //LoRa.setCodingRate4(codingRateDenominator); LoRa.setPins(SS, RST, DIO0); if (!LoRa.begin(frequency)) { Serial.println(\"LoRa init failed.\"); while (true); } LoRa.setSpreadingFactor(7); LoRa.setCodingRate4(8); LoRa.setSyncWord(netID); LoRa.enableCrc(); LoRa_rxMode(); prevMil = millis(); prevMilSU = millis(); Serial.println(\"Node startup complete\"); sendSensorData(0, 3); } void loop() { unsigned long currentMillis = millis(); // Receive Downlink msg int packetSize = LoRa.parsePacket(); if (packetSize) { onReceive(packetSize); } // Send Uplink msg if((currentMillis-prevMil) > TIMEOUT_INTERVAL){ getMsgFromQueueAndSend(currentMillis); } // Send node status if((currentMillis-prevMilSU) > STATUS_UPDATE_INTERVAL){ byte msgID = random(MAX_MSG_ID); //sendStatus(msgID); prevMilSU = currentMillis; } } Updated on 2022-09-09 at 17:40:11 +0000","title":"Source code"},{"location":"Node/Files/node__definitions_8h/","text":"node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. More... Attributes Name const byte netID const int sensN const int actN Defines Name BAUD_RATE Detailed Description Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable netID const byte netID = 0xF3; variable sensN const int sensN = sizeof(sensPin)/sizeof(int); variable actN const int actN = sizeof(actPin)/sizeof(int); Macros Documentation define BAUD_RATE #define BAUD_RATE 115200 Source code #ifndef NODE_DEFINITIONS_H #define NODE_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 115200 // Node Settings const byte netID = 0xF3; #include \"node_definitions/node_definitions_3.h\" const int sensN = sizeof(sensPin)/sizeof(int); const int actN = sizeof(actPin)/sizeof(int); #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"node_definitions.h"},{"location":"Node/Files/node__definitions_8h/#node_definitionsh","text":"Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. More...","title":"node_definitions.h"},{"location":"Node/Files/node__definitions_8h/#attributes","text":"Name const byte netID const int sensN const int actN","title":"Attributes"},{"location":"Node/Files/node__definitions_8h/#defines","text":"Name BAUD_RATE","title":"Defines"},{"location":"Node/Files/node__definitions_8h/#detailed-description","text":"Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions_8h/#variable-netid","text":"const byte netID = 0xF3;","title":"variable netID"},{"location":"Node/Files/node__definitions_8h/#variable-sensn","text":"const int sensN = sizeof(sensPin)/sizeof(int);","title":"variable sensN"},{"location":"Node/Files/node__definitions_8h/#variable-actn","text":"const int actN = sizeof(actPin)/sizeof(int);","title":"variable actN"},{"location":"Node/Files/node__definitions_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions_8h/#define-baud_rate","text":"#define BAUD_RATE 115200","title":"define BAUD_RATE"},{"location":"Node/Files/node__definitions_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_H #define NODE_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 115200 // Node Settings const byte netID = 0xF3; #include \"node_definitions/node_definitions_3.h\" const int sensN = sizeof(sensPin)/sizeof(int); const int actN = sizeof(actPin)/sizeof(int); #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__1_8h/","text":"/sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; variable nodeID const byte nodeID = 0x01; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"/sensor_network/node/node_definitions/node_definitions_1.h"},{"location":"Node/Files/node__definitions__1_8h/#sensor_networknodenode_definitionsnode_definitions_1h","text":"Definitions for node with id 1. More...","title":"/sensor_network/node/node_definitions/node_definitions_1.h"},{"location":"Node/Files/node__definitions__1_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__1_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__1_8h/#detailed-description","text":"Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__1_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__1_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f };","title":"variable key"},{"location":"Node/Files/node__definitions__1_8h/#variable-nodeid","text":"const byte nodeID = 0x01;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__1_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__1_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__1_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__1_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__1_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__1_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__1_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__1_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__1_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__1_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__1_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__2_8h/","text":"/sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 2. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; variable nodeID const byte nodeID = 0x02; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_2_H #define NODE_DEFINITIONS_2_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x02; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"/sensor_network/node/node_definitions/node_definitions_2.h"},{"location":"Node/Files/node__definitions__2_8h/#sensor_networknodenode_definitionsnode_definitions_2h","text":"Definitions for node with id 2. More...","title":"/sensor_network/node/node_definitions/node_definitions_2.h"},{"location":"Node/Files/node__definitions__2_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__2_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__2_8h/#detailed-description","text":"Definitions for node with id 2. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__2_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__2_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f };","title":"variable key"},{"location":"Node/Files/node__definitions__2_8h/#variable-nodeid","text":"const byte nodeID = 0x02;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__2_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__2_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__2_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__2_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__2_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__2_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__2_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__2_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__2_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__2_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__2_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_2_H #define NODE_DEFINITIONS_2_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x02; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__3_8h/","text":"/sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 3. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f }; variable nodeID const byte nodeID = 0x03; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_3_H #define NODE_DEFINITIONS_3_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x03; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"/sensor_network/node/node_definitions/node_definitions_3.h"},{"location":"Node/Files/node__definitions__3_8h/#sensor_networknodenode_definitionsnode_definitions_3h","text":"Definitions for node with id 3. More...","title":"/sensor_network/node/node_definitions/node_definitions_3.h"},{"location":"Node/Files/node__definitions__3_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__3_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__3_8h/#detailed-description","text":"Definitions for node with id 3. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__3_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__3_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f };","title":"variable key"},{"location":"Node/Files/node__definitions__3_8h/#variable-nodeid","text":"const byte nodeID = 0x03;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__3_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__3_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__3_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__3_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__3_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__3_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__3_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__3_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__3_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__3_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__3_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_3_H #define NODE_DEFINITIONS_3_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x03; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__4_8h/","text":"/sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. More... Attributes Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin Defines Name SCK MISO MOSI SS RST DIO0 Detailed Description Definitions for node with id 4. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }; variable nodeID const byte nodeID = 0x04; variable vbatPin const int vbatPin = 35; variable sensPin const int sensPin = {16}; variable actPin const int actPin = {LED_BUILTIN}; Macros Documentation define SCK #define SCK 5 define MISO #define MISO 19 define MOSI #define MOSI 27 define SS #define SS 18 define RST #define RST 14 define DIO0 #define DIO0 26 Source code #ifndef NODE_DEFINITIONS_4_H #define NODE_DEFINITIONS_4_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x04; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"/sensor_network/node/node_definitions/node_definitions_4.h"},{"location":"Node/Files/node__definitions__4_8h/#sensor_networknodenode_definitionsnode_definitions_4h","text":"Definitions for node with id 4. More...","title":"/sensor_network/node/node_definitions/node_definitions_4.h"},{"location":"Node/Files/node__definitions__4_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__4_8h/#defines","text":"Name SCK MISO MOSI SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__4_8h/#detailed-description","text":"Definitions for node with id 4. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__4_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__4_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f };","title":"variable key"},{"location":"Node/Files/node__definitions__4_8h/#variable-nodeid","text":"const byte nodeID = 0x04;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__4_8h/#variable-vbatpin","text":"const int vbatPin = 35;","title":"variable vbatPin"},{"location":"Node/Files/node__definitions__4_8h/#variable-senspin","text":"const int sensPin = {16};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__4_8h/#variable-actpin","text":"const int actPin = {LED_BUILTIN};","title":"variable actPin"},{"location":"Node/Files/node__definitions__4_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__4_8h/#define-sck","text":"#define SCK 5","title":"define SCK"},{"location":"Node/Files/node__definitions__4_8h/#define-miso","text":"#define MISO 19","title":"define MISO"},{"location":"Node/Files/node__definitions__4_8h/#define-mosi","text":"#define MOSI 27","title":"define MOSI"},{"location":"Node/Files/node__definitions__4_8h/#define-ss","text":"#define SS 18","title":"define SS"},{"location":"Node/Files/node__definitions__4_8h/#define-rst","text":"#define RST 14","title":"define RST"},{"location":"Node/Files/node__definitions__4_8h/#define-dio0","text":"#define DIO0 26","title":"define DIO0"},{"location":"Node/Files/node__definitions__4_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_4_H #define NODE_DEFINITIONS_4_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x04; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"Source code"},{"location":"Node/Files/node__definitions__uno_8h/","text":"/sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. More... Attributes Name const uint8_t key const byte nodeID const int sensPin const int actPin Defines Name SS RST DIO0 Detailed Description Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022 Attributes Documentation variable key const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; variable nodeID const byte nodeID = 0x01; variable sensPin const int sensPin = {}; variable actPin const int actPin = {4}; Macros Documentation define SS #define SS 10 define RST #define RST 9 define DIO0 #define DIO0 2 Source code #ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int sensPin[] = {}; const int actPin[] = {4}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"/sensor_network/node/node_definitions/node_definitions_uno.h"},{"location":"Node/Files/node__definitions__uno_8h/#sensor_networknodenode_definitionsnode_definitions_unoh","text":"Definitions for node with id 1. More...","title":"/sensor_network/node/node_definitions/node_definitions_uno.h"},{"location":"Node/Files/node__definitions__uno_8h/#attributes","text":"Name const uint8_t key const byte nodeID const int sensPin const int actPin","title":"Attributes"},{"location":"Node/Files/node__definitions__uno_8h/#defines","text":"Name SS RST DIO0","title":"Defines"},{"location":"Node/Files/node__definitions__uno_8h/#detailed-description","text":"Definitions for node with id 1. Author : Francisco Santos ( francisco.velez@tecnico.ulisboa.pt ) Version : 1.0 Date : 2022-08-10 Copyright : Copyright (c) 2022","title":"Detailed Description"},{"location":"Node/Files/node__definitions__uno_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"Node/Files/node__definitions__uno_8h/#variable-key","text":"const uint8_t key = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f };","title":"variable key"},{"location":"Node/Files/node__definitions__uno_8h/#variable-nodeid","text":"const byte nodeID = 0x01;","title":"variable nodeID"},{"location":"Node/Files/node__definitions__uno_8h/#variable-senspin","text":"const int sensPin = {};","title":"variable sensPin"},{"location":"Node/Files/node__definitions__uno_8h/#variable-actpin","text":"const int actPin = {4};","title":"variable actPin"},{"location":"Node/Files/node__definitions__uno_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"Node/Files/node__definitions__uno_8h/#define-ss","text":"#define SS 10","title":"define SS"},{"location":"Node/Files/node__definitions__uno_8h/#define-rst","text":"#define RST 9","title":"define RST"},{"location":"Node/Files/node__definitions__uno_8h/#define-dio0","text":"#define DIO0 2","title":"define DIO0"},{"location":"Node/Files/node__definitions__uno_8h/#source-code","text":"#ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int sensPin[] = {}; const int actPin[] = {4}; #endif Updated on 2022-09-09 at 17:40:10 +0000","title":"Source code"},{"location":"Node/Modules/","text":"Modules Updated on 2022-09-09 at 17:40:11 +0000","title":"Modules"},{"location":"Node/Modules/#modules","text":"Updated on 2022-09-09 at 17:40:11 +0000","title":"Modules"},{"location":"Node/Namespaces/","text":"Namespaces Updated on 2022-09-09 at 17:40:11 +0000","title":"Namespaces"},{"location":"Node/Namespaces/#namespaces","text":"Updated on 2022-09-09 at 17:40:11 +0000","title":"Namespaces"},{"location":"Node/Pages/","text":"Pages Updated on 2022-09-09 at 17:40:11 +0000","title":"Pages"},{"location":"Node/Pages/#pages","text":"Updated on 2022-09-09 at 17:40:11 +0000","title":"Pages"},{"location":"pages/example_usage/","text":"Example Usage As an example, a network was set-up with 2 node devices. The Arduino uno with the SX1276 Dragino shield was used as the hardware platform for the gateway and the TTGO LoRa ESP32 modules were used for the node devices. Regarding sensors and actuators, a motion sensor was attached to each of the nodes and the builtin LED was used as an actuator. node_definitions_1.h file: #ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif node_definitions_2.h file: #ifndef NODE_DEFINITIONS_2_H #define NODE_DEFINITIONS_2_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x02; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif gateway_serial_definitions.h file: #ifndef GATEWAY_SERIAL_DEFINITIONS_H #define GATEWAY_SERIAL_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 9600 // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Gateway Settings const byte netID = 0xF3; #endif On the comms_protocol.h file the keys arrays should be: // Encryption keys const uint8_t keys[][KEY_SIZE] = {{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f },{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }, { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }}; After this, the code can be uploaded to both the nodes and the gateway. wsn_config.yaml file: wsn_config: gateways: - { 'serial_port': '/dev/ttyUSB0' } nodes: - id: 0x01 location: - x: 3 y: 1 sensors: - id: 0x00 name: 'motion sensor' pinMap: [16] actuators: - id: 0x00 name: 'BUILTINLED' pinMap: [5] - id: 0x02 location: - x: 4 y: 3 sensors: - id: 0x00 name: 'motion sensor' pinMap: [16] actuators: - id: 0x00 name: 'BUILTINLED' pinMap: [5] The Python application is now configured for this network and can be run.","title":"Example Usage"},{"location":"pages/example_usage/#example-usage","text":"As an example, a network was set-up with 2 node devices. The Arduino uno with the SX1276 Dragino shield was used as the hardware platform for the gateway and the TTGO LoRa ESP32 modules were used for the node devices. Regarding sensors and actuators, a motion sensor was attached to each of the nodes and the builtin LED was used as an actuator. node_definitions_1.h file: #ifndef NODE_DEFINITIONS_1_H #define NODE_DEFINITIONS_1_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x01; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif node_definitions_2.h file: #ifndef NODE_DEFINITIONS_2_H #define NODE_DEFINITIONS_2_H // Node Encryption key const uint8_t key[] = { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }; // SPI pinout for TTGO boards #define SCK 5 #define MISO 19 #define MOSI 27 // LoRa Modem Pinout for TTGO boards #define SS 18 #define RST 14 #define DIO0 26 // Node Settings const byte nodeID = 0x02; // Node I/O Pinout const int vbatPin = 35; const int sensPin[] = {16}; const int actPin[] = {LED_BUILTIN}; #endif gateway_serial_definitions.h file: #ifndef GATEWAY_SERIAL_DEFINITIONS_H #define GATEWAY_SERIAL_DEFINITIONS_H // Baud rate for serial communication #define BAUD_RATE 9600 // LoRa Modem Pinout for boards with the Dragino LoRa shield #define SS 10 #define RST 9 #define DIO0 2 // Gateway Settings const byte netID = 0xF3; #endif On the comms_protocol.h file the keys arrays should be: // Encryption keys const uint8_t keys[][KEY_SIZE] = {{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f },{ // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }, { // 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f }}; After this, the code can be uploaded to both the nodes and the gateway. wsn_config.yaml file: wsn_config: gateways: - { 'serial_port': '/dev/ttyUSB0' } nodes: - id: 0x01 location: - x: 3 y: 1 sensors: - id: 0x00 name: 'motion sensor' pinMap: [16] actuators: - id: 0x00 name: 'BUILTINLED' pinMap: [5] - id: 0x02 location: - x: 4 y: 3 sensors: - id: 0x00 name: 'motion sensor' pinMap: [16] actuators: - id: 0x00 name: 'BUILTINLED' pinMap: [5] The Python application is now configured for this network and can be run.","title":"Example Usage"},{"location":"pages/install_guide/","text":"Install Guide Requirements In order to set-up such a wireless sensor network, the following software is required: Arduino IDE; Python3. Additionally, the following Arduino libraries are required: LoRa.h ; cppQueue.h ; aes256.h . Clone the repository After ensuring all the aforementioned requirements are met this repository can be cloned and the contents can be opened in an editor like VScode: git clone https://github.com/hardtekpt/sensor_network cd sensor_network code . Configuration The packages now need to be configured according to the hardware available. The network has been tested with both the Arduino Uno platform using the SX1276 Dragino Shield and with the TTGO LoRa ESP32 modules. To this extent, the pin map for the LoRa radio must be configured for all devices: On the Gateway edit the file gateway_serial_definitions.h ; On every Node use the node_definitions folder and create a file for each node. This file is referenced by node_definitions.h . Additionally, every node needs a unique 32 byte encryption key. This key must also be added to the gateway_serial_definitions.h file. Finally, every node needs a unique hexadecimal ID. The gateway has the encryption keys of all the nodes in an array indexed by the node's ID. Regarding the Network Manager, the wsn_config.yaml file must be edited to include: The serial port where gateway is attached; Information regarding each node: ID; Geographic location; Sensors; Actuators; It should be noted that example configurations for each file are included in the repository. The last thing to do is to attach any sensors and actuators to the nodes and upload the code. For this, see Example Usage .","title":"Install Guide"},{"location":"pages/install_guide/#install-guide","text":"","title":"Install Guide"},{"location":"pages/install_guide/#requirements","text":"In order to set-up such a wireless sensor network, the following software is required: Arduino IDE; Python3. Additionally, the following Arduino libraries are required: LoRa.h ; cppQueue.h ; aes256.h .","title":"Requirements"},{"location":"pages/install_guide/#clone-the-repository","text":"After ensuring all the aforementioned requirements are met this repository can be cloned and the contents can be opened in an editor like VScode: git clone https://github.com/hardtekpt/sensor_network cd sensor_network code .","title":"Clone the repository"},{"location":"pages/install_guide/#configuration","text":"The packages now need to be configured according to the hardware available. The network has been tested with both the Arduino Uno platform using the SX1276 Dragino Shield and with the TTGO LoRa ESP32 modules. To this extent, the pin map for the LoRa radio must be configured for all devices: On the Gateway edit the file gateway_serial_definitions.h ; On every Node use the node_definitions folder and create a file for each node. This file is referenced by node_definitions.h . Additionally, every node needs a unique 32 byte encryption key. This key must also be added to the gateway_serial_definitions.h file. Finally, every node needs a unique hexadecimal ID. The gateway has the encryption keys of all the nodes in an array indexed by the node's ID. Regarding the Network Manager, the wsn_config.yaml file must be edited to include: The serial port where gateway is attached; Information regarding each node: ID; Geographic location; Sensors; Actuators; It should be noted that example configurations for each file are included in the repository. The last thing to do is to attach any sensors and actuators to the nodes and upload the code. For this, see Example Usage .","title":"Configuration"},{"location":"pages/repo_structure/","text":"Repository Structure This repository consists of three packages: Node : Arduino code for node devices; Gateway : Arduino code for gateway devices; Network Manager : Python application for monitoring, managing and communicating with the network.","title":"Repository Structure"},{"location":"pages/repo_structure/#repository-structure","text":"This repository consists of three packages: Node : Arduino code for node devices; Gateway : Arduino code for gateway devices; Network Manager : Python application for monitoring, managing and communicating with the network.","title":"Repository Structure"}]}